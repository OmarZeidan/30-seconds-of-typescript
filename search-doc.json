[{"title":"Accumulate","type":0,"sectionRef":"#","url":"docs/","content":"Returns an array of partial sums.Use Array.prototype.reduce(), Array.prototype.slice(-1) and the unary + operator to add each value to the unary array containing the previous sum.Copyconst accumulate = (...nums: number[]): number[] => nums.reduce((acc: number[], n) => [...acc, n + +acc.slice(-1)], []); Copyaccumulate(1, 2, 3, 4); // [1, 3, 6, 10]accumulate(...[1, 2, 3, 4]); // [1, 3, 6, 10]"},{"title":"CSVToArray","type":0,"sectionRef":"#","url":"docs/CSVToArray","content":"Converts a comma-separated values (CSV) string to a 2D array.Use Array.prototype.slice() and Array.prototype.indexOf('\\n') to remove the first row (title row) if omitFirstRow is true. Use String.prototype.split('\\n') to create a string for each row, then String.prototype.split(delimiter) to separate the values in each row. Omit the second argument, delimiter, to use a default delimiter of ,. Omit the third argument, omitFirstRow, to include the first row (title row) of the CSV string.Copyconst CSVToArray = (data, delimiter = ',', omitFirstRow = false) => data .slice(omitFirstRow ? data.indexOf('\\n') + 1 : 0) .split('\\n') .map(v => v.split(delimiter));CopyCSVToArray('a,b\\nc,d'); // [['a','b'],['c','d']];CSVToArray('a;b\\nc;d', ';'); // [['a','b'],['c','d']];CSVToArray('col1,col2\\na,b\\nc,d', ',', true); // [['a','b'],['c','d']];"},{"title":"CSVToJSON","type":0,"sectionRef":"#","url":"docs/CSVToJSON","content":"Converts a comma-separated values (CSV) string to a 2D array of objects. The first row of the string is used as the title row.Use Array.prototype.slice() and Array.prototype.indexOf('\\n') and String.prototype.split(delimiter) to separate the first row (title row) into values. Use String.prototype.split('\\n') to create a string for each row, then Array.prototype.map() and String.prototype.split(delimiter) to separate the values in each row. Use Array.prototype.reduce() to create an object for each row's values, with the keys parsed from the title row. Omit the second argument, delimiter, to use a default delimiter of ,.Copyconst CSVToJSON = (data, delimiter = ',') => { const titles = data.slice(0, data.indexOf('\\n')).split(delimiter); return data .slice(data.indexOf('\\n') + 1) .split('\\n') .map(v => { const values = v.split(delimiter); return titles.reduce((obj, title, index) => ((obj[title] = values[index]), obj), {}); });};CopyCSVToJSON('col1,col2\\na,b\\nc,d'); // [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];CSVToJSON('col1;col2\\na;b\\nc;d', ';'); // [{'col1': 'a', 'col2': 'b'}, {'col1': 'c', 'col2': 'd'}];"},{"title":"JSONToFile","type":0,"sectionRef":"#","url":"docs/JSONToFile","content":"Writes a JSON object to a file.Use fs.writeFileSync(), template literals and JSON.stringify() to write a json object to a .json file.Copyconst fs = require('fs');const JSONToFile = (obj, filename) => fs.writeFileSync(`${filename}.json`, JSON.stringify(obj, null, 2));CopyJSONToFile({ test: 'is passed' }, 'testJsonFile'); // writes the object to 'testJsonFile.json'"},{"title":"JSONtoCSV","type":0,"sectionRef":"#","url":"docs/JSONtoCSV","content":"Converts an array of objects to a comma-separated values (CSV) string that contains only the columns specified.Use Array.prototype.join(delimiter) to combine all the names in columns to create the first row. Use Array.prototype.map() and Array.prototype.reduce() to create a row for each object, substituting non-existent values with empty strings and only mapping values in columns. Use Array.prototype.join('\\n') to combine all rows into a string. Omit the third argument, delimiter, to use a default delimiter of ,.Copyconst JSONtoCSV = (arr, columns, delimiter = ',') => [ columns.join(delimiter), ...arr.map(obj => columns.reduce( (acc, key) => `${acc}${!acc.length ? '' : delimiter}\"${!obj[key] ? '' : obj[key]}\"`, '' ) ) ].join('\\n');CopyJSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b']); // 'a,b\\n\"1\",\"2\"\\n\"3\",\"4\"\\n\"6\",\"\"\\n\"\",\"7\"'JSONtoCSV([{ a: 1, b: 2 }, { a: 3, b: 4, c: 5 }, { a: 6 }, { b: 7 }], ['a', 'b'], ';'); // 'a;b\\n\"1\";\"2\"\\n\"3\";\"4\"\\n\"6\";\"\"\\n\"\";\"7\"'"},{"title":"RGBToHex","type":0,"sectionRef":"#","url":"docs/RGBToHex","content":"Converts the values of RGB components to a color code.Convert given RGB parameters to hexadecimal string using bitwise left-shift operator (<<) and toString(16), then String.padStart(6,'0') to get a 6-digit hexadecimal value.Copyconst RGBToHex = (r, g, b) => ((r << 16) + (g << 8) + b).toString(16).padStart(6, '0');CopyRGBToHex(255, 165, 1); // 'ffa501'"},{"title":"URLJoin","type":0,"sectionRef":"#","url":"docs/URLJoin","content":"Joins all given URL segments together, then normalizes the resulting URL.Use String.prototype.join('/') to combine URL segments, then a series of String.prototype.replace() calls with various regexps to normalize the resulting URL (remove double slashes, add proper slashes for protocol, remove slashes before parameters, combine parameters with '&' and normalize first parameter delimiter).Copyconst URLJoin = (...args) => args .join('/') .replace(/[\\/]+/g, '/') .replace(/^(.+):\\//, '$1://') .replace(/^file:/, 'file:/') .replace(/\\/(\\?|&|#[^!])/g, '$1') .replace(/\\?/g, '&') .replace('&', '?');CopyURLJoin('http://www.google.com', 'a', '/b/cd', '?foo=123', '?bar=foo'); // 'http://www.google.com/a/b/cd?foo=123&bar=foo'"},{"title":"UUIDGeneratorBrowser","type":0,"sectionRef":"#","url":"docs/UUIDGeneratorBrowser","content":"Generates a UUID in a browser.Use crypto API to generate a UUID, compliant with RFC4122 version 4.Copyconst UUIDGeneratorBrowser = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16) );CopyUUIDGeneratorBrowser(); // '7982fcfe-5721-4632-bede-6000885be57d'"},{"title":"UUIDGeneratorNode","type":0,"sectionRef":"#","url":"docs/UUIDGeneratorNode","content":"Generates a UUID in Node.JS.Use crypto API to generate a UUID, compliant with RFC4122 version 4.Copyconst crypto = require('crypto');const UUIDGeneratorNode = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ (crypto.randomBytes(1)[0] & (15 >> (c / 4)))).toString(16) );CopyUUIDGeneratorNode(); // '79c7c136-60ee-40a2-beb2-856f1feabefc'"},{"title":"All","type":0,"sectionRef":"#","url":"docs/all","content":"Returns true if the provided predicate function returns true for all elements in a collection, false otherwise.Use Array.prototype.every() to test if all elements in the collection return true based on fn. Omit the second argument, fn, to use Boolean as a default.Copyconst all = <T extends any>(arr: T[], fn: (t: T) => boolean = Boolean) => arr.every(fn);CopyassertEquals(all([1, 2, 3, 4]), true);assertEquals(all([2, null, 1]), false); const hasName = (user: any) => Boolean(user.name);assertEquals(all([{ name: \"D\" }, { name: \"D2\" }], hasName), true);assertEquals(all([{ name: \"D\" }, { name: \"\" }], hasName), false);"},{"title":"AllEqual","type":0,"sectionRef":"#","url":"docs/allEqual","content":"Check if all elements in an array are equal.Use Array.prototype.every() to check if all the elements of the array are the same as the first one. Elements in the array are compared using the strict comparison operator, which does not account for NaN self-inequality.Copyconst allEqual = <T extends any>(arr: T[]) => arr.every((val) => val === arr[0]);CopyallEqual([1, 2, 3, 4, 5, 6]); // falseallEqual([1, 1, 1, 1]); // true"},{"title":"And","type":0,"sectionRef":"#","url":"docs/and","content":"Returns true if both arguments are true, false otherwise.Use the logical and (&&) operator on the two given values.Copyconst and = <T extends any = boolean>(a: T, b: T) => Boolean(a) && Boolean(b);Copyand(true, true); // trueand(true, false); // falseand(false, false); // false"},{"title":"Any","type":0,"sectionRef":"#","url":"docs/any","content":"Returns true if the provided predicate function returns true for at least one element in a collection, false otherwise.Use Array.prototype.some() to test if any elements in the collection return true based on fn. Omit the second argument, fn, to use Boolean as a default.Copyconst any = <T extends any>(arr: T[], fn: (t: T) => boolean = Boolean) => arr.some(fn);Copyany([0, 1, 2, 0], (x) => x >= 2); // trueany([0, 0, 1, 0]); // true"},{"title":"Aperture","type":0,"sectionRef":"#","url":"docs/aperture","content":"Returns an array of n-tuples of consecutive elements.Use Array.prototype.slice() and Array.prototype.map() to create an array of appropriate length and populate it with n-tuples of consecutive elements from arr. If n is greater than the length of arr, return an empty array.Copyconst aperture = <T extends any>(n: number, arr: T[]) => n >= arr.length ? [] : arr.slice(n - 1).map((v, i) => [...arr.slice(i, i + n - 1), v]);Copyaperture(2, [1, 2, 3, 4]); // [[1, 2], [2, 3], [3, 4]]aperture(3, [1, 2, 3, 4]); // [[1, 2, 3], [2, 3, 4]]aperture(5, [1, 2, 3, 4]); // [1, 2, 3, 4]"},{"title":"ApproximatelyEqual","type":0,"sectionRef":"#","url":"docs/approximatelyEqual","content":"Checks if two numbers are approximately equal to each other.Use Math.abs() to compare the absolute difference of the two values to epsilon. Omit the third parameter, epsilon, to use a default value of 0.001.Copyexport const approximatelyEqual = ( v1: number, v2: number, epsilon: number = 0.001) => Math.abs(v1 - v2) < epsilon;CopyapproximatelyEqual(Math.PI / 2.0, 1.5708); // trueapproximatelyEqual(Math.PI / 2.0, 1.5708, 0.000001); // false // 1.5707963267948966"},{"title":"ArrayToCSV","type":0,"sectionRef":"#","url":"docs/arrayToCSV","content":"Converts a 2D array to a comma-separated values (CSV) string.Use Array.prototype.map() and Array.prototype.join(delimiter) to combine individual 1D arrays (rows) into strings. Use Array.prototype.join('\\n') to combine all rows into a CSV string, separating each row with a newline. Omit the second argument, delimiter, to use a default delimiter of ,.Copytype StringOrNumber = string | number;const arrayToCSV = (arr: StringOrNumber[][], delimiter = \",\") => arr .map((v) => v .map((x) => (typeof x === \"string\" ? `\"${x.replace(/\"/g, '\"\"')}\"` : x)) .join(delimiter) ) .join(\"\\n\");CopyarrayToCSV([['a', 'b'], ['c', 'd']]); // '\"a\",\"b\"\\n\"c\",\"d\"'arrayToCSV([['a', 'b'], ['c', 'd']], ';'); // '\"a\";\"b\"\\n\"c\";\"d\"'arrayToCSV([['a', '\"b\" great'], ['c', 3.1415]]); // '\"a\",\"\"\"b\"\" great\"\\n\"c\",3.1415'"},{"title":"ArrayToHtmlList","type":0,"sectionRef":"#","url":"docs/arrayToHtmlList","content":"Converts the given array elements into <li> tags and appends them to the list of the given id.Use Array.prototype.map(), document.querySelector(), and an anonymous inner closure to create a list of html tags.Copyconst arrayToHtmlList = (arr: (string | number)[], listID: string) => { let el = document.querySelector(\"#\" + listID); if (el) { el.innerHTML += arr.map((item) => `<li>${item}</li>`).join(\"\"); }};CopyarrayToHtmlList([\"item 1\", \"item 2\"], \"myListID\"); // <li>item1</li><li>item2</li>"},{"title":"Ary","type":0,"sectionRef":"#","url":"docs/ary","content":"Creates a function that accepts up to n arguments, ignoring any additional arguments.Call the provided function, fn, with up to n arguments, using Array.prototype.slice(0, n) and the spread operator (...).Copyconst ary = <T extends any>(fn: (...args: T[]) => any, n: number) => ( ...args: T[]) => fn(...args.slice(0, n));Copyconst firstTwoMax = ary(Math.max, 2);[[2, 6, 12], [6, 4, 8], [10]].map((x) => firstTwoMax(...x)); // [6, 6, 10]"},{"title":"atob","type":0,"sectionRef":"#","url":"docs/atob","content":"Decodes a string of data which has been encoded using base-64 encoding.Create a Buffer for the given string with base-64 encoding and use Buffer.toString('binary') to return the decoded string.Copyconst atob = str => Buffer.from(str, 'base64').toString('binary');Copyatob('Zm9vYmFy'); // 'foobar'"},{"title":"Attempt","type":0,"sectionRef":"#","url":"docs/attempt","content":""},{"title":"attempt2","type":1,"pageTitle":"Attempt","url":"docs/attempt#attempt2","content":"Same as attempt but it return tuple of result and error. Copyconst attempt2 = (fn: (...args: any[]) => any, ...args: any[]) => { try { return [fn(...args), null]; } catch (e) { return [null, e instanceof Error ? e : new Error(e)]; }}; Copylet [elements, error] = attempt2(function (selector) { return document.querySelectorAll(selector);}, \">_>\");if (error instanceof Error) elements = []; // elements = [] const isValidNumber = (num: number) => { if (num >= 0) { return num; } throw new Error(\"Invalid number\");};const [ten] = attempt2(isValidNumber, 10);assertEquals(ten, 10); const [res, error] = attempt2(isValidNumber, -1);assertEquals(res, null);assertEquals(error instanceof Error, true);assertEquals(error.message, \"Invalid number\"); "},{"title":"Average","type":0,"sectionRef":"#","url":"docs/average","content":"Returns the average of two or more numbers.Use Array.prototype.reduce() to add each value to an accumulator, initialized with a value of 0, divide by the length of the array.Copyconst average = <T extends number>(...nums: number[]) => nums.reduce((acc, val) => acc + val, 0) / nums.length;Copyaverage(...[1, 2, 3, 4]); // 2.5average(1, 2, 3); // 2"},{"title":"AverageBy","type":0,"sectionRef":"#","url":"docs/averageBy","content":"Returns the average of an array, after mapping each element to a value using the provided function.Use Array.prototype.map() to map each element to the value returned by fn, Array.prototype.reduce() to add each value to an accumulator, initialized with a value of 0, divide by the length of the array.Copytype NumCollector<T> = (item: T) => number;const averageBy = <T extends any>(arr: T[], fn: NumCollector<T> | string) => { const mapper = typeof fn === \"function\" ? fn : (val: any) => val[fn]; return arr.reduce((acc, val) => acc + mapper(val), 0) / arr.length;};CopyaverageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], (o) => o.n); // 5averageBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], \"n\"); // 5"},{"title":"Bifurcate","type":0,"sectionRef":"#","url":"docs/bifurcate","content":"Splits values into two groups. If an element in filter is truthy, the corresponding element in the collection belongs to the first group; otherwise, it belongs to the second group.Use Array.prototype.reduce() and Array.prototype.push() to add elements to groups, based on filter.Copyconst bifurcate = <T extends any>(arr: T[], filter: boolean[]) => arr.reduce( (acc, val, i) => { acc[filter[i] ? 0 : 1].push(val); return acc; }, [[] as T[], [] as T[]] );Copybifurcate([\"beep\", \"boop\", \"foo\", \"bar\"], [true, true, false, true]); // [ ['beep', 'boop', 'bar'], ['foo'] ]"},{"title":"BifurcateBy","type":0,"sectionRef":"#","url":"docs/bifurcateBy","content":"Splits values into two groups according to a predicate function, which specifies which group an element in the input collection belongs to. If the predicate function returns a truthy value, the collection element belongs to the first group; otherwise, it belongs to the second group.Use Array.prototype.reduce() and Array.prototype.push() to add elements to groups, based on the value returned by fn for each element.Copytype Predicate<T> = (item: T) => boolean; const bifurcateBy = <T extends any>(arr: T[], filter: Predicate<T>) => arr.reduce( (acc, val) => { acc[filter(val) ? 0 : 1].push(val); return acc; }, [[] as T[], [] as T[]] );CopybifurcateBy([\"beep\", \"boop\", \"foo\", \"bar\"], (x: string) => x[0] === \"b\"); // [ ['beep', 'boop', 'bar'], ['foo'] ] // To Get Filtered(falsy) values const [filtered] = bifurcateBy([\"beep\", \"boop\", undefined, null, 1], Boolean); // filtered == [\"beep\", \"boop\", 1] assertEquals( bifurcate([\"beep\", \"boop\", \"foo\", \"bar\"], (item: string) => item.startsWith(\"b\") ), [[\"beep\", \"boop\", \"bar\"], [\"foo\"]]);"},{"title":"Binary","type":0,"sectionRef":"#","url":"docs/binary","content":"Creates a function that accepts up to two arguments, ignoring any additional arguments.Call the provided function, fn, with the first two arguments given.Copyexport const binary = (fn: (...args: any[]) => any) => ( ...[v1, v2]: any[]) => fn(v1, v2);Copyconst max = binary(Math.max)(1, 2, 3);assertEquals(max, 2); [\"2\", \"1\", \"0\"].map(binary(Math.max)); // [2, 1, 2]"},{"title":"Bind","type":0,"sectionRef":"#","url":"docs/bind","content":"Creates a function that invokes fn with a given context, optionally adding any additional supplied parameters to the beginning of the arguments.Return a function that uses Function.prototype.apply() to apply the given context to fn. Use Array.prototype.concat() to prepend any additional supplied parameters to the arguments.Copyexport const bind = <T extends any>( fn: (...args: any[]) => any, context: T, ...boundArgs: any[]) => (...args: any[]) => fn.apply(context, [...boundArgs, ...args]);TS: You need to bind this typeCopyconst freddy = { user: \"fred\" };function greet(this: typeof freddy, greeting: string, punctuation: string) { return greeting + \" \" + this.user + punctuation;}const freddyBound = bind(greet, freddy);console.log(freddyBound(\"hi\", \"!\")); // 'hi fred!'JS Version:Copyfunction greet(greeting, punctuation) { return greeting + \" \" + this.user + punctuation;}const freddy = { user: \"fred\" };const freddyBound = bind(greet, freddy);console.log(freddyBound(\"hi\", \"!\")); // 'hi fred!'"},{"title":"BindAll","type":0,"sectionRef":"#","url":"docs/bindAll","content":"Binds methods of an object to the object itself, overwriting the existing method.Use Array.prototype.forEach() to return a function that uses Function.prototype.apply() to apply the given context (obj) to fn for each function specified.Copyexport const bindAll = (obj: any, ...fns: string[]) => fns.forEach((key: string) => { if (typeof obj[key] === \"function\") { const f = obj[key]; obj[key] = function (...args: any[]) { return f.apply(obj, args); }; } });Copyclass User { #name = \"Test\"; getName() { return this.#name; }}const user = new User();bindAll(user, \"getName\"); const getName = user.getName;assertEquals(getName(), \"Test\"); // JSvar view = { label: \"docs\", click: function () { console.log(\"clicked \" + this.label); },};bindAll(view, \"click\");jQuery(element).on(\"click\", view.click); // Logs 'clicked docs' when clicked.React:Copyclass Toggle extends React.Component { constructor(props) { super(props); bindAll(this, \"handleClick\", \"handleMove\"); } handleClick() { // code } handleMove() { // code } render() { // code }}"},{"title":"bindKey","type":0,"sectionRef":"#","url":"docs/bindKey","content":"Creates a function that invokes the method at a given key of an object, optionally adding any additional supplied parameters to the beginning of the arguments.Return a function that uses Function.prototype.apply() to bind context[fn] to context. Use the spread operator (...) to prepend any additional supplied parameters to the arguments.Copyconst bindKey = (context, fn, ...boundArgs) => (...args) => context[fn].apply(context, [...boundArgs, ...args]);Copyconst freddy = { user: 'fred', greet: function(greeting, punctuation) { return greeting + ' ' + this.user + punctuation; }};const freddyBound = bindKey(freddy, 'greet');console.log(freddyBound('hi', '!')); // 'hi fred!'"},{"title":"BinomialCoefficient","type":0,"sectionRef":"#","url":"docs/binomialCoefficient","content":"Evaluates the binomial coefficient of two integers n and k.Use Number.isNaN() to check if any of the two values is NaN. Check if k is less than 0, greater than or equal to n, equal to 1 or n - 1 and return the appropriate result. Check if n - k is less than k and switch their values accordingly. Loop from 2 through k and calculate the binomial coefficient. Use Math.round() to account for rounding errors in the calculation.Copyconst binomialCoefficient = (n: number, k: number): number => { if (Number.isNaN(n) || Number.isNaN(k)) return NaN; if (k < 0 || k > n) return 0; if (k === 0 || k === n) return 1; if (k === 1 || k === n - 1) return n; if (n - k < k) k = n - k; let res = n; for (let j = 2; j <= k; j++) res *= (n - j + 1) / j; return Math.round(res);};CopybinomialCoefficient(8, 2); // 28const result = binomialCoefficient(8, 2);assertEquals(result, 28);"},{"title":"Both","type":0,"sectionRef":"#","url":"docs/both","content":"Returns true if both functions return true for a given set of arguments, false otherwise.Use the logical and (&&) operator on the result of calling the two functions with the supplied args.Copytype Func<T> = (...args: T[]) => any;export const both = <T extends any>(f: Func<T>, g: Func<T>) => (...args: T[]) => f(...args) && g(...args);Copyconst isEven = (num: number) => num % 2 === 0;const isPositive = (num: number) => num > 0;const isPositiveEven = both(isEven, isPositive);isPositiveEven(4); // trueisPositiveEven(-2); // false"},{"title":"bottomVisible","type":0,"sectionRef":"#","url":"docs/bottomVisible","content":"Returns true if the bottom of the page is visible, false otherwise.Use scrollY, scrollHeight and clientHeight to determine if the bottom of the page is visible.Copyconst bottomVisible = () => document.documentElement.clientHeight + window.scrollY >= (document.documentElement.scrollHeight || document.documentElement.clientHeight);CopybottomVisible(); // true"},{"title":"btoa","type":0,"sectionRef":"#","url":"docs/btoa","content":"Creates a base-64 encoded ASCII string from a String object in which each character in the string is treated as a byte of binary data.Create a Buffer for the given string with binary encoding and use Buffer.toString('base64') to return the encoded string.Copyconst btoa = str => Buffer.from(str, 'binary').toString('base64');Copybtoa('foobar'); // 'Zm9vYmFy'"},{"title":"byteSize","type":0,"sectionRef":"#","url":"docs/byteSize","content":"Returns the length of a string in bytes.Convert a given string to a Blob Object and find its size.Copyconst byteSize = str => new Blob([str]).size;CopybyteSize('😀'); // 4byteSize('Hello World'); // 11"},{"title":"call","type":0,"sectionRef":"#","url":"docs/call","content":"Given a key and a set of arguments, call them when given a context. Primarily useful in composition.Use a closure to call a stored key with stored arguments.Copyconst call = (key, ...args) => context => context[key](...args);CopyPromise.resolve([1, 2, 3]) .then(call('map', x => 2 * x)) .then(console.log); // [ 2, 4, 6 ]const map = call.bind(null, 'map');Promise.resolve([1, 2, 3]) .then(map(x => 2 * x)) .then(console.log); // [ 2, 4, 6 ]"},{"title":"Capitalize","type":0,"sectionRef":"#","url":"docs/capitalize","content":"Capitalizes the first letter of a string.Use array destructuring and String.prototype.toUpperCase() to capitalize first letter, ...rest to get array of characters after first letter and then Array.prototype.join('') to make it a string again. Omit the lowerRest parameter to keep the rest of the string intact, or set it to true to convert to lowercase.Copyconst capitalize = (str: string = \"\", lowerRest = false): string => str.slice(0, 1).toUpperCase() + (lowerRest ? str.slice(1).toLowerCase() : str.slice(1));Copycapitalize(\"fooBar\"); // 'FooBar'capitalize(\"fooBar\", true); // 'Foobar'"},{"title":"capitalizeEveryWord","type":0,"sectionRef":"#","url":"docs/capitalizeEveryWord","content":"Capitalizes the first letter of every word in a string.Use String.prototype.replace() to match the first character of each word and String.prototype.toUpperCase() to capitalize it.Copyconst capitalizeEveryWord = (str: string = \"\") => str.replace(/\\b[a-z]/g, (char) => char.toUpperCase());CopycapitalizeEveryWord(\"hello world!\"); // 'Hello World!'"},{"title":"castArray","type":0,"sectionRef":"#","url":"docs/castArray","content":"Casts the provided value as an array if it's not one.Use Array.prototype.isArray() to determine if val is an array and return it as-is or encapsulated in an array accordingly.Copyexport const castArray = (val: any): any[] => Array.isArray(val) ? val : [val];CopycastArray(\"foo\"); // ['foo']castArray([1]); // [1]"},{"title":"celsiusToFahrenheit","type":0,"sectionRef":"#","url":"docs/celsiusToFahrenheit","content":"Converts Celsius to Fahrenheit.Follows the conversion formula F = 1.8C + 32.Copyconst celsiusToFahrenheit = (degrees: number) => 1.8 * degrees + 32;CopycelsiusToFahrenheit(33); // 91.4"},{"title":"chainAsync","type":0,"sectionRef":"#","url":"docs/chainAsync","content":"Chains asynchronous functions.Loop through an array of functions containing asynchronous events, calling next when each asynchronous event has completed.Copyconst chainAsync = fns => { let curr = 0; const last = fns[fns.length - 1]; const next = () => { const fn = fns[curr++]; fn === last ? fn() : fn(next); }; next();};CopychainAsync([ next => { console.log('0 seconds'); setTimeout(next, 1000); }, next => { console.log('1 second'); setTimeout(next, 1000); }, () => { console.log('2 second'); }]);"},{"title":"checkProp","type":0,"sectionRef":"#","url":"docs/checkProp","content":"Given a predicate function and a prop string, this curried function will then take an object to inspect by calling the property and passing it to the predicate.Summon prop on obj, pass it to a provided predicate function and return a masked boolean.Copyconst checkProp = (predicate, prop) => obj => !!predicate(obj[prop]);Copyconst lengthIs4 = checkProp(l => l === 4, 'length');lengthIs4([]); // falselengthIs4([1, 2, 3, 4]); // truelengthIs4(new Set([1, 2, 3, 4])); // false (Set uses Size, not length) const session = { user: {} };const validUserSession = checkProp(u => u.active && !u.disabled, 'user'); validUserSession(session); // false session.user.active = true;validUserSession(session); // true const noLength = checkProp(l => l === undefined, 'length');noLength([]); // falsenoLength({}); // truenoLength(new Set()); // true"},{"title":"chunk","type":0,"sectionRef":"#","url":"docs/chunk","content":"Chunks an array into smaller arrays of a specified size.Use Array.from() to create a new array, that fits the number of chunks that will be produced. Use Array.prototype.slice() to map each element of the new array to a chunk the length of size. If the original array can't be split evenly, the final chunk will contain the remaining elements.Copyexport const chunk = (arr: any[], size: number) => Array.from({ length: Math.ceil(arr.length / size) }, (_: any, i: number) => arr.slice(i * size, i * size + size) );Copychunk([1, 2, 3, 4, 5], 2); // [[1,2],[3,4],[5]]"},{"title":"chunkIntoN","type":0,"sectionRef":"#","url":"docs/chunkIntoN","content":"Chunks an array into n smaller arrays.Use Math.ceil() and Array.prototype.length to get the size of each chunk. Use Array.from() to create a new array of size n. Use Array.prototype.slice() to map each element of the new array to a chunk the length of size. If the original array can't be split evenly, the final chunk will contain the remaining elements.Copyconst chunkIntoN = (arr, n) => { const size = Math.ceil(arr.length / n); return Array.from({ length: n }, (v, i) => arr.slice(i * size, i * size + size) );}CopychunkIntoN([1, 2, 3, 4, 5, 6, 7], 4); // [[1,2], [3,4], [5,6], [7]]"},{"title":"clampNumber","type":0,"sectionRef":"#","url":"docs/clampNumber","content":"Clamps num within the inclusive range specified by the boundary values a and b.If num falls within the range, return num. Otherwise, return the nearest number in the range.Copyconst clampNumber = (num, a, b) => Math.max(Math.min(num, Math.max(a, b)), Math.min(a, b));CopyclampNumber(2, 3, 5); // 3clampNumber(1, -1, -5); // -1"},{"title":"cloneRegExp","type":0,"sectionRef":"#","url":"docs/cloneRegExp","content":"Clones a regular expression.Use new RegExp(), RegExp.source and RegExp.flags to clone the given regular expression.Copyconst cloneRegExp = regExp => new RegExp(regExp.source, regExp.flags);Copyconst regExp = /lorem ipsum/gi;const regExp2 = cloneRegExp(regExp); // /lorem ipsum/gi"},{"title":"coalesce","type":0,"sectionRef":"#","url":"docs/coalesce","content":"Returns the first defined, non-null argument.Use Array.prototype.find() and Array.prototype.includes() to find the first value that is not equal to undefined or null.Copyconst coalesce = (...args) => args.find(v => ![undefined, null].includes(v));Copycoalesce(null, undefined, '', NaN, 'Waldo'); // ''"},{"title":"coalesceFactory","type":0,"sectionRef":"#","url":"docs/coalesceFactory","content":"Returns a customized coalesce function that returns the first argument that returns true from the provided argument validation function.Use Array.prototype.find() to return the first argument that returns true from the provided argument validation function.Copyconst coalesceFactory = valid => (...args) => args.find(valid);Copyconst customCoalesce = coalesceFactory(_ => ![null, undefined, '', NaN].includes(_));customCoalesce(undefined, null, NaN, '', 'Waldo'); // \"Waldo\""},{"title":"collectInto","type":0,"sectionRef":"#","url":"docs/collectInto","content":"Changes a function that accepts an array into a variadic function.Given a function, return a closure that collects all inputs into an array-accepting function.Copyconst collectInto = fn => (...args) => fn(args);Copyconst Pall = collectInto(Promise.all.bind(Promise));let p1 = Promise.resolve(1);let p2 = Promise.resolve(2);let p3 = new Promise(resolve => setTimeout(resolve, 2000, 3));Pall(p1, p2, p3).then(console.log); // [1, 2, 3] (after about 2 seconds)"},{"title":"colorize","type":0,"sectionRef":"#","url":"docs/colorize","content":"Add special characters to text to print in color in the console (combined with console.log()).Use template literals and special characters to add the appropriate color code to the string output. For background colors, add a special character that resets the background color at the end of the string.Copyexport const colorize = new (class { color = (code: number, ended = false, ...messages: any[]) => `\\x1b[${code}m${messages.join(\" \")}${ended ? \"\\x1b[0m\" : \"\"}`; black = this.color.bind(null, 30, false); red = this.color.bind(null, 31, false); green = this.color.bind(null, 32, false); yellow = this.color.bind(this, 33, false); blue = this.color.bind(this, 34, false); magenta = this.color.bind(this, 35, false); cyan = this.color.bind(this, 36, false); white = this.color.bind(this, 37, false); bgBlack = this.color.bind(this, 40, true); bgRed = this.color.bind(this, 41, true); bgGreen = this.color.bind(this, 42, true); bgYellow = this.color.bind(this, 43, true); bgBlue = this.color.bind(this, 44, true); bgMagenta = this.color.bind(this, 45, true); bgCyan = this.color.bind(this, 46, true); bgWhite = this.color.bind(this, 47, true);})();Copyconsole.log(colorize.red(\"foo\")); // 'foo' (red letters)console.log(colorize.bgBlue(\"foo\", \"bar\")); // 'foo bar' (blue background)console.log(colorize.bgWhite(colorize.yellow(\"foo\"), colorize.green(\"foo\"))); // 'foo bar' (first//word in yellow letters, second word in green letters, white background for both)"},{"title":"compact","type":0,"sectionRef":"#","url":"docs/compact","content":"Removes falsy values from an array.Use Array.prototype.filter() to filter out falsy values (false, null, 0, \"\", undefined, and NaN).Copyconst compact = arr => arr.filter(Boolean);Copycompact([0, 1, false, 2, '', 3, 'a', 'e' * 23, NaN, 's', 34]); // [ 1, 2, 3, 'a', 's', 34 ]"},{"title":"compactWhitespace","type":0,"sectionRef":"#","url":"docs/compactWhitespace","content":"Returns a string with whitespaces compacted.Use String.prototype.replace() with a regular expression to replace all occurrences of 2 or more whitespace characters with a single space.Copyconst compactWhitespace = str => str.replace(/\\s{2,}/g, ' ');CopycompactWhitespace('Lorem Ipsum'); // 'Lorem Ipsum'compactWhitespace('Lorem \\n Ipsum'); // 'Lorem Ipsum'"},{"title":"complement","type":0,"sectionRef":"#","url":"docs/complement","content":"Returns a function that is the logical complement of the given function, fn.Use the logical not (!) operator on the result of calling fn with any supplied args.Copyconst complement = fn => (...args) => !fn(...args);Copyconst isEven = num => num % 2 === 0;const isOdd = complement(isEven);isOdd(2); // falseisOdd(3); // true"},{"title":"compose","type":0,"sectionRef":"#","url":"docs/compose","content":"Performs right-to-left function composition.Use Array.prototype.reduce() to perform right-to-left function composition. The last (rightmost) function can accept one or more arguments; the remaining functions must be unary.Copyconst compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));Copyconst add5 = x => x + 5;const multiply = (x, y) => x * y;const multiplyAndAdd5 = compose( add5, multiply);multiplyAndAdd5(5, 2); // 15"},{"title":"composeRight","type":0,"sectionRef":"#","url":"docs/composeRight","content":"Performs left-to-right function composition.Use Array.prototype.reduce() to perform left-to-right function composition. The first (leftmost) function can accept one or more arguments; the remaining functions must be unary.Copyconst composeRight = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));Copyconst add = (x, y) => x + y;const square = x => x * x;const addAndSquare = composeRight(add, square);addAndSquare(1, 2); // 9"},{"title":"containsWhitespace","type":0,"sectionRef":"#","url":"docs/containsWhitespace","content":"Returns true if the given string contains any whitespace characters, false otherwise.Use RegExp.prototype.test() with an appropriate regular expression to check if the given string contains any whitespace characters.Copyconst containsWhitespace = str => /\\s/.test(str);CopycontainsWhitespace('lorem'); // falsecontainsWhitespace('lorem ipsum'); // true"},{"title":"converge","type":0,"sectionRef":"#","url":"docs/converge","content":"Accepts a converging function and a list of branching functions and returns a function that applies each branching function to the arguments and the results of the branching functions are passed as arguments to the converging function.Use Array.prototype.map() and Function.prototype.apply() to apply each function to the given arguments. Use the spread operator (...) to call coverger with the results of all other functions.Copyconst converge = (converger, fns) => (...args) => converger(...fns.map(fn => fn.apply(null, args)));Copyconst average = converge((a, b) => a / b, [ arr => arr.reduce((a, v) => a + v, 0), arr => arr.length]);average([1, 2, 3, 4, 5, 6, 7]); // 4"},{"title":"copyToClipboard","type":0,"sectionRef":"#","url":"docs/copyToClipboard","content":"Copy a string to the clipboard. Only works as a result of user action (i.e. inside a click event listener).⚠️ NOTICE: The same functionality can be easily implemented by using the new asynchronous Clipboard API, which is still experimental but should be used in the future instead of this snippet. Find out more about it here.Create a new <textarea> element, fill it with the supplied data and add it to the HTML document. Use Selection.getRangeAt()to store the selected range (if any). Use document.execCommand('copy') to copy to the clipboard. Remove the <textarea> element from the HTML document. Finally, use Selection().addRange() to recover the original selected range (if any).Copyconst copyToClipboard = str => { const el = document.createElement('textarea'); el.value = str; el.setAttribute('readonly', ''); el.style.position = 'absolute'; el.style.left = '-9999px'; document.body.appendChild(el); const selected = document.getSelection().rangeCount > 0 ? document.getSelection().getRangeAt(0) : false; el.select(); document.execCommand('copy'); document.body.removeChild(el); if (selected) { document.getSelection().removeAllRanges(); document.getSelection().addRange(selected); }};CopycopyToClipboard('Lorem ipsum'); // 'Lorem ipsum' copied to clipboard."},{"title":"countBy","type":0,"sectionRef":"#","url":"docs/countBy","content":"Groups the elements of an array based on the given function and returns the count of elements in each group.Use Array.prototype.map() to map the values of an array to a function or property name. Use Array.prototype.reduce() to create an object, where the keys are produced from the mapped results.Copyconst countBy = (arr, fn) => arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => { acc[val] = (acc[val] || 0) + 1; return acc; }, {});CopycountBy([6.1, 4.2, 6.3], Math.floor); // {4: 1, 6: 2}countBy(['one', 'two', 'three'], 'length'); // {3: 2, 5: 1}"},{"title":"countOccurrences","type":0,"sectionRef":"#","url":"docs/countOccurrences","content":"Counts the occurrences of a value in an array.Use Array.prototype.reduce() to increment a counter each time you encounter the specific value inside the array.Copyconst countOccurrences = (arr, val) => arr.reduce((a, v) => (v === val ? a + 1 : a), 0);CopycountOccurrences([1, 1, 2, 1, 2, 3], 1); // 3"},{"title":"counter","type":0,"sectionRef":"#","url":"docs/counter","content":"Creates a counter with the specified range, step and duration for the specified selector.Check if step has the proper sign and change it accordingly. Use setInterval() in combination with Math.abs() and Math.floor() to calculate the time between each new text draw. Use document.querySelector().innerHTML to update the value of the selected element. Omit the fourth parameter, step, to use a default step of 1. Omit the fifth parameter, duration, to use a default duration of 2000ms.Copyconst counter = (selector, start, end, step = 1, duration = 2000) => { let current = start, _step = (end - start) * step < 0 ? -step : step, timer = setInterval(() => { current += _step; document.querySelector(selector).innerHTML = current; if (current >= end) document.querySelector(selector).innerHTML = end; if (current >= end) clearInterval(timer); }, Math.abs(Math.floor(duration / (end - start)))); return timer;};Copycounter('#my-id', 1, 1000, 5, 2000); // Creates a 2-second timer for the element with id=\"my-id\""},{"title":"createDirIfNotExists","type":0,"sectionRef":"#","url":"docs/createDirIfNotExists","content":"Creates a directory, if it does not exist.Use fs.existsSync() to check if the directory exists, fs.mkdirSync() to create it.Copyconst fs = require('fs');const createDirIfNotExists = dir => (!fs.existsSync(dir) ? fs.mkdirSync(dir) : undefined);CopycreateDirIfNotExists('test'); // creates the directory 'test', if it doesn't exist"},{"title":"createElement","type":0,"sectionRef":"#","url":"docs/createElement","content":"Creates an element from a string (without appending it to the document). If the given string contains multiple elements, only the first one will be returned.Use document.createElement() to create a new element. Set its innerHTML to the string supplied as the argument. Use ParentNode.firstElementChild to return the element version of the string.Copyconst createElement = str => { const el = document.createElement('div'); el.innerHTML = str; return el.firstElementChild;};Copyconst el = createElement( `<div class=\"container\"> <p>Hello!</p> </div>`);console.log(el.className); // 'container'"},{"title":"createEventHub","type":0,"sectionRef":"#","url":"docs/createEventHub","content":"Creates a pub/sub (publish–subscribe) event hub with emit, on, and off methods.Use Object.create(null) to create an empty hub object that does not inherit properties from Object.prototype. For emit, resolve the array of handlers based on the event argument and then run each one with Array.prototype.forEach() by passing in the data as an argument. For on, create an array for the event if it does not yet exist, then use Array.prototype.push() to add the handler to the array. For off, use Array.prototype.findIndex() to find the index of the handler in the event array and remove it using Array.prototype.splice().Copyconst createEventHub = () => ({ hub: Object.create(null), emit(event, data) { (this.hub[event] || []).forEach(handler => handler(data)); }, on(event, handler) { if (!this.hub[event]) this.hub[event] = []; this.hub[event].push(handler); }, off(event, handler) { const i = (this.hub[event] || []).findIndex(h => h === handler); if (i > -1) this.hub[event].splice(i, 1); if (this.hub[event].length === 0) delete this.hub[event]; }});Copyconst handler = data => console.log(data);const hub = createEventHub();let increment = 0; // Subscribe: listen for different types of eventshub.on('message', handler);hub.on('message', () => console.log('Message event fired'));hub.on('increment', () => increment++); // Publish: emit events to invoke all handlers subscribed to them, passing the data to them as an argumenthub.emit('message', 'hello world'); // logs 'hello world' and 'Message event fired'hub.emit('message', { hello: 'world' }); // logs the object and 'Message event fired'hub.emit('increment'); // `increment` variable is now 1 // Unsubscribe: stop a specific handler from listening to the 'message' eventhub.off('message', handler);"},{"title":"currentURL","type":0,"sectionRef":"#","url":"docs/currentURL","content":"Returns the current URL.Use window.location.href to get the current URL.Copyconst currentURL = () => window.location.href;CopycurrentURL(); // 'https://google.com'"},{"title":"curry","type":0,"sectionRef":"#","url":"docs/curry","content":"Curries a function.Use recursion. If the number of provided arguments (args) is sufficient, call the passed function fn. Otherwise, return a curried function fn that expects the rest of the arguments. If you want to curry a function that accepts a variable number of arguments (a variadic function, e.g. Math.min()), you can optionally pass the number of arguments to the second parameter arity.Copyconst curry = (fn, arity = fn.length, ...args) => arity <= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);Copycurry(Math.pow)(2)(10); // 1024curry(Math.min, 3)(10)(50)(2); // 2"},{"title":"dayOfYear","type":0,"sectionRef":"#","url":"docs/dayOfYear","content":"Gets the day of the year from a Date object.Use new Date() and Date.prototype.getFullYear() to get the first day of the year as a Date object, subtract it from the provided date and divide with the milliseconds in each day to get the result. Use Math.floor() to appropriately round the resulting day count to an integer.Copyconst dayOfYear = date => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);CopydayOfYear(new Date()); // 272"},{"title":"debounce","type":0,"sectionRef":"#","url":"docs/debounce","content":"Creates a debounced function that delays invoking the provided function until at least ms milliseconds have elapsed since the last time it was invoked.Each time the debounced function is invoked, clear the current pending timeout with clearTimeout() and use setTimeout() to create a new timeout that delays invoking the function until at least ms milliseconds has elapsed. Use Function.prototype.apply() to apply the this context to the function and provide the necessary arguments. Omit the second argument, ms, to set the timeout at a default of 0 ms.Copyconst debounce = (fn, ms = 0) => { let timeoutId; return function(...args) { clearTimeout(timeoutId); timeoutId = setTimeout(() => fn.apply(this, args), ms); };};Copywindow.addEventListener( 'resize', debounce(() => { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms"},{"title":"decapitalize","type":0,"sectionRef":"#","url":"docs/decapitalize","content":"Decapitalizes the first letter of a string.Use array destructuring and String.toLowerCase() to decapitalize first letter, ...rest to get array of characters after first letter and then Array.prototype.join('') to make it a string again. Omit the upperRest parameter to keep the rest of the string intact, or set it to true to convert to uppercase.Copyconst decapitalize = ([first, ...rest], upperRest = false) => first.toLowerCase() + (upperRest ? rest.join('').toUpperCase() : rest.join(''));Copydecapitalize('FooBar'); // 'fooBar'decapitalize('FooBar', true); // 'fOOBAR'"},{"title":"deepClone","type":0,"sectionRef":"#","url":"docs/deepClone","content":"Creates a deep clone of an object.Use recursion. Check if the passed object is null and, if so, return null. Use Object.assign() and an empty object ({}) to create a shallow clone of the original. Use Object.keys() and Array.prototype.forEach() to determine which key-value pairs need to be deep cloned.Copyconst deepClone = obj => { if (obj === null) return null; let clone = Object.assign({}, obj); Object.keys(clone).forEach( key => (clone[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key]) ); return Array.isArray(obj) && obj.length ? (clone.length = obj.length) && Array.from(clone) : Array.isArray(obj) ? Array.from(obj) : clone;};Copyconst a = { foo: 'bar', obj: { a: 1, b: 2 } };const b = deepClone(a); // a !== b, a.obj !== b.obj"},{"title":"deepFlatten","type":0,"sectionRef":"#","url":"docs/deepFlatten","content":"Deep flattens an array.Use recursion. Use Array.prototype.concat() with an empty array ([]) and the spread operator (...) to flatten an array. Recursively flatten each element that is an array.Copyconst deepFlatten = arr => [].concat(...arr.map(v => (Array.isArray(v) ? deepFlatten(v) : v)));CopydeepFlatten([1, [2], [[3], 4], 5]); // [1, 2, 3, 4, 5]"},{"title":"deepFreeze","type":0,"sectionRef":"#","url":"docs/deepFreeze","content":"Deep freezes an object.Use Object.keys() to get all the properties of the passed object, Array.prototype.forEach() to iterate over them. Call Object.freeze(obj) recursively on all properties, checking if each one is frozen using Object.isFrozen() and applying deepFreeze() as necessary. Finally, use Object.freeze() to freeze the given object.Copyconst deepFreeze = obj => { Object.keys(obj).forEach(prop => { if (obj[prop] === 'object' && !Object.isFrozen(obj[prop])) deepFreeze(v[prop]); }); return Object.freeze(obj);};Copy'use strict'; const o = deepFreeze([1, [2, 3]]); o[0] = 3; // not allowedo[1][0] = 4; // not allowed as well"},{"title":"deepGet","type":0,"sectionRef":"#","url":"docs/deepGet","content":"Returns the target value in a nested JSON object, based on the keys array.Compare the keys you want in the nested JSON object as an Array. Use Array.prototype.reduce() to get value from nested JSON object one by one. If the key exists in object, return target value, otherwise, return null.Copyconst deepGet = (obj, keys) => keys.reduce((xs, x) => (xs && xs[x] ? xs[x] : null), obj);Copylet index = 2;const data = { foo: { foz: [1, 2, 3], bar: { baz: ['a', 'b', 'c'] } }};deepGet(data, ['foo', 'foz', index]); // get 3deepGet(data, ['foo', 'bar', 'baz', 8, 'foz']); // null"},{"title":"deepMapKeys","type":0,"sectionRef":"#","url":"docs/deepMapKeys","content":"Deep maps an object's keys.Creates an object with the same values as the provided object and keys generated by running the provided function for each key. Use Object.keys(obj) to iterate over the object's keys. Use Array.prototype.reduce() to create a new object with the same values and mapped keys using fn.Copyconst deepMapKeys = (obj, fn) => Array.isArray(obj) ? obj.map(val => deepMapKeys(val, fn)) : typeof obj === 'object' ? Object.keys(obj).reduce((acc, current) => { const key = fn(current); const val = obj[current]; acc[key] = val !== null && typeof val === 'object' ? deepMapKeys(val, fn) : val; return acc; }, {}) : obj;Copyconst obj = { foo: '1', nested: { child: { withArray: [ { grandChild: ['hello'] } ] } }};const upperKeysObj = deepMapKeys(obj, key => key.toUpperCase());/*{ \"FOO\":\"1\", \"NESTED\":{ \"CHILD\":{ \"WITHARRAY\":[ { \"GRANDCHILD\":[ 'hello' ] } ] } }}*/"},{"title":"defaults","type":0,"sectionRef":"#","url":"docs/defaults","content":"Assigns default values for all properties in an object that are undefined.Use Object.assign() to create a new empty object and copy the original one to maintain key order, use Array.prototype.reverse() and the spread operator ... to combine the default values from left to right, finally use obj again to overwrite properties that originally had a value.Copyconst defaults = (obj, ...defs) => Object.assign({}, obj, ...defs.reverse(), obj);Copydefaults({ a: 1 }, { b: 2 }, { b: 6 }, { a: 3 }); // { a: 1, b: 2 }"},{"title":"defer","type":0,"sectionRef":"#","url":"docs/defer","content":"Defers invoking a function until the current call stack has cleared.Use setTimeout() with a timeout of 1ms to add a new event to the browser event queue and allow the rendering engine to complete its work. Use the spread (...) operator to supply the function with an arbitrary number of arguments.Copyconst defer = (fn, ...args) => setTimeout(fn, 1, ...args);Copy// Example A:defer(console.log, 'a'), console.log('b'); // logs 'b' then 'a' // Example B:document.querySelector('#someElement').innerHTML = 'Hello';longRunningFunction(); // Browser will not update the HTML until this has finisheddefer(longRunningFunction); // Browser will update the HTML then run the function"},{"title":"degreesToRads","type":0,"sectionRef":"#","url":"docs/degreesToRads","content":"Converts an angle from degrees to radians.Use Math.PI and the degree to radian formula to convert the angle from degrees to radians.Copyconst degreesToRads = deg => (deg * Math.PI) / 180.0;CopydegreesToRads(90.0); // ~1.5708"},{"title":"delay","type":0,"sectionRef":"#","url":"docs/delay","content":"Invokes the provided function after wait milliseconds.Use setTimeout() to delay execution of fn. Use the spread (...) operator to supply the function with an arbitrary number of arguments.Copyconst delay = (fn, wait, ...args) => setTimeout(fn, wait, ...args);Copydelay( function(text) { console.log(text); }, 1000, 'later'); // Logs 'later' after one second."},{"title":"detectDeviceType","type":0,"sectionRef":"#","url":"docs/detectDeviceType","content":"Detects whether the website is being opened in a mobile device or a desktop/laptop.Use a regular expression to test the navigator.userAgent property to figure out if the device is a mobile device or a desktop/laptop.Copyconst detectDeviceType = () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ? 'Mobile' : 'Desktop';CopydetectDeviceType(); // \"Mobile\" or \"Desktop\""},{"title":"difference","type":0,"sectionRef":"#","url":"docs/difference","content":"Returns the difference between two arrays.Create a Set from b, then use Array.prototype.filter() on a to only keep values not contained in b.Copyconst difference = (a, b) => { const s = new Set(b); return a.filter(x => !s.has(x));};Copydifference([1, 2, 3], [1, 2, 4]); // [3]"},{"title":"differenceBy","type":0,"sectionRef":"#","url":"docs/differenceBy","content":"Returns the difference between two arrays, after applying the provided function to each array element of both.Create a Set by applying fn to each element in b, then use Array.prototype.map() to apply fn to each element in a, then Array.prototype.filter()Copyconst differenceBy = (a, b, fn) => { const s = new Set(b.map(fn)); return a.map(fn).filter(el => !s.has(el));};CopydifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [1]differenceBy([{ x: 2 }, { x: 1 }], [{ x: 1 }], v => v.x); // [2]"},{"title":"differenceWith","type":0,"sectionRef":"#","url":"docs/differenceWith","content":"Filters out all values from an array for which the comparator function does not return true.Use Array.prototype.filter() and Array.prototype.findIndex() to find the appropriate values.Copyconst differenceWith = (arr, val, comp) => arr.filter(a => val.findIndex(b => comp(a, b)) === -1);CopydifferenceWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2]"},{"title":"dig","type":0,"sectionRef":"#","url":"docs/dig","content":"Returns the target value in a nested JSON object, based on the given key.Use the in operator to check if target exists in obj. If found, return the value of obj[target], otherwise use Object.values(obj) and Array.prototype.reduce() to recursively call dig on each nested object until the first matching key/value pair is found.Copyconst dig = (obj, target) => target in obj ? obj[target] : Object.values(obj).reduce((acc, val) => { if (acc !== undefined) return acc; if (typeof val === 'object') return dig(val, target); }, undefined);Copyconst data = { level1: { level2: { level3: 'some data' } }};dig(data, 'level3'); // 'some data'dig(data, 'level4'); // undefined"},{"title":"digitize","type":0,"sectionRef":"#","url":"docs/digitize","content":"Converts a number to an array of digits.Convert the number to a string, using the spread operator (...) to build an array. Use Array.prototype.map() and parseInt() to transform each value to an integer.Copyconst digitize = n => [...`${n}`].map(i => parseInt(i));Copydigitize(123); // [1, 2, 3]"},{"title":"distance","type":0,"sectionRef":"#","url":"docs/distance","content":"Returns the distance between two points.Use Math.hypot() to calculate the Euclidean distance between two points.Copyconst distance = (x0, y0, x1, y1) => Math.hypot(x1 - x0, y1 - y0);Copydistance(1, 1, 2, 3); // 2.23606797749979"},{"title":"Style GuideH1 - Create the best documentation#","type":0,"sectionRef":"#","url":"docs/doc1","content":""},{"title":"Markdown Syntax","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#markdown-syntax","content":"To serve as an example page when styling markdown based Docusaurus sites. "},{"title":"Headers","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#headers","content":"H1 - Create the best documentation# "},{"title":"H2 - Create the best documentation","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#h2---create-the-best-documentation","content":""},{"title":"Emphasis","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#emphasis","content":"Emphasis, aka italics, with asterisks or underscores. Strong emphasis, aka bold, with asterisks or underscores. Combined emphasis with asterisks and underscores. Strikethrough uses two tildes. Scratch this.  "},{"title":"Lists","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#lists","content":"First ordered list itemAnother itemUnordered sub-list.Actual numbers don't matter, just that it's a numberOrdered sub-listAnd another item. Unordered list can use asterisks Or minuses Or pluses  "},{"title":"Links","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#links","content":"I'm an inline-style link I'm an inline-style link with title I'm a reference-style link I'm a relative reference to a repository file You can use numbers for reference-style link definitions Or leave it empty and use the link text itself. URLs and URLs in angle brackets will automatically get turned into links. http://www.example.com/ or http://www.example.com/ and sometimes example.com (but not on GitHub, for example). Some text to show that the reference links can follow later.  "},{"title":"Images","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#images","content":"Here's our logo (hover to see the title text): Inline-style:  Reference-style:   "},{"title":"Code","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#code","content":"Copyvar s = 'JavaScript syntax highlighting';alert(s); Copys = \"Python syntax highlighting\"print(s) CopyNo language indicated, so no syntax highlighting.But let's throw in a <b>tag</b>. Copyfunction highlightMe() { console.log('This line can be highlighted!');}  "},{"title":"Tables","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#tables","content":"Colons can be used to align columns.  Tables Are Cool col 3 is right-aligned \\$1600 col 2 is centered \\$12 zebra stripes are neat \\$1  There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.  Markdown Less Pretty Still renders nicely 1 2 3   "},{"title":"Blockquotes","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#blockquotes","content":"Blockquotes are very handy in email to emulate reply text. This line is part of the same quote. Quote break. This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.  "},{"title":"Inline HTML","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#inline-html","content":"Definition listIs something people use sometimes.Markdown in HTMLDoes *not* work **very** well. Use HTML tags.  "},{"title":"Line Breaks","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#line-breaks","content":"Here's a line for us to start with. This line is separated from the one above by two newlines, so it will be a separate paragraph. This line is also a separate paragraph, but... This line is only separated by a single newline, so it's a separate line in the same paragraph.  "},{"title":"Admonitions","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#admonitions","content":"noteThis is a note tipThis is a tip importantThis is important cautionThis is a caution warningThis is a warning "},{"title":"H3 - Create the best documentation","type":1,"pageTitle":"Style GuideH1 - Create the best documentation#","url":"docs/doc1#h3---create-the-best-documentation","content":"H4 - Create the best documentation# H5 - Create the best documentation# H6 - Create the best documentation#  "},{"title":"Document Number 2","type":0,"sectionRef":"#","url":"docs/doc2","content":"This is a link to another document. This is a link to an external page."},{"title":"This is Document Number 3","type":0,"sectionRef":"#","url":"docs/doc3","content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. In ac euismod odio, eu consequat dui. Nullam molestie consectetur risus id imperdiet. Proin sodales ornare turpis, non mollis massa ultricies id. Nam at nibh scelerisque, feugiat ante non, dapibus tortor. Vivamus volutpat diam quis tellus elementum bibendum. Praesent semper gravida velit quis aliquam. Etiam in cursus neque. Nam lectus ligula, malesuada et mauris a, bibendum faucibus mi. Phasellus ut interdum felis. Phasellus in odio pulvinar, porttitor urna eget, fringilla lectus. Aliquam sollicitudin est eros. Mauris consectetur quam vitae mauris interdum hendrerit. Lorem ipsum dolor sit amet, consectetur adipiscing elit.Duis et egestas libero, imperdiet faucibus ipsum. Sed posuere eget urna vel feugiat. Vivamus a arcu sagittis, fermentum urna dapibus, congue lectus. Fusce vulputate porttitor nisl, ac cursus elit volutpat vitae. Nullam vitae ipsum egestas, convallis quam non, porta nibh. Morbi gravida erat nec neque bibendum, eu pellentesque velit posuere. Fusce aliquam erat eu massa eleifend tristique.Sed consequat sollicitudin ipsum eget tempus. Integer a aliquet velit. In justo nibh, pellentesque non suscipit eget, gravida vel lacus. Donec odio ante, malesuada in massa quis, pharetra tristique ligula. Donec eros est, tristique eget finibus quis, semper non nisl. Vivamus et elit nec enim ornare placerat. Sed posuere odio a elit cursus sagittis.Phasellus feugiat purus eu tortor ultrices finibus. Ut libero nibh, lobortis et libero nec, dapibus posuere eros. Sed sagittis euismod justo at consectetur. Nulla finibus libero placerat, cursus sapien at, eleifend ligula. Vivamus elit nisl, hendrerit ac nibh eu, ultrices tempus dui. Nam tellus neque, commodo non rhoncus eu, gravida in risus. Nullam id iaculis tortor.Nullam at odio in sem varius tempor sit amet vel lorem. Etiam eu hendrerit nisl. Fusce nibh mauris, vulputate sit amet ex vitae, congue rhoncus nisl. Sed eget tellus purus. Nullam tempus commodo erat ut tristique. Cras accumsan massa sit amet justo consequat eleifend. Integer scelerisque vitae tellus id consectetur."},{"title":"drop","type":0,"sectionRef":"#","url":"docs/drop","content":"Returns a new array with n elements removed from the left.Use Array.prototype.slice() to remove the specified number of elements from the left.Copyconst drop = (arr, n = 1) => arr.slice(n);Copydrop([1, 2, 3]); // [2,3]drop([1, 2, 3], 2); // [3]drop([1, 2, 3], 42); // []"},{"title":"dropRight","type":0,"sectionRef":"#","url":"docs/dropRight","content":"Returns a new array with n elements removed from the right.Use Array.prototype.slice() to remove the specified number of elements from the right.Copyconst dropRight = (arr, n = 1) => arr.slice(0, -n);CopydropRight([1, 2, 3]); // [1,2]dropRight([1, 2, 3], 2); // [1]dropRight([1, 2, 3], 42); // []"},{"title":"dropRightWhile","type":0,"sectionRef":"#","url":"docs/dropRightWhile","content":"Removes elements from the end of an array until the passed function returns true. Returns the remaining elements in the array.Loop through the array, using Array.prototype.slice() to drop the last element of the array until the returned value from the function is true. Returns the remaining elements.Copyconst dropRightWhile = (arr, func) => { let rightIndex = arr.length; while (rightIndex-- && !func(arr[rightIndex])); return arr.slice(0, rightIndex + 1);};CopydropRightWhile([1, 2, 3, 4], n => n < 3); // [1, 2]"},{"title":"dropWhile","type":0,"sectionRef":"#","url":"docs/dropWhile","content":"Removes elements in an array until the passed function returns true. Returns the remaining elements in the array.Loop through the array, using Array.prototype.slice() to drop the first element of the array until the returned value from the function is true. Returns the remaining elements.Copyconst dropWhile = (arr, func) => { while (arr.length > 0 && !func(arr[0])) arr = arr.slice(1); return arr;};CopydropWhile([1, 2, 3, 4], n => n >= 3); // [3, 4]"},{"title":"either","type":0,"sectionRef":"#","url":"docs/either","content":"Returns true if at least one function returns true for a given set of arguments, false otherwise.Use the logical or (||) operator on the result of calling the two functions with the supplied args.Copyconst either = (f, g) => (...args) => f(...args) || g(...args);Copyconst isEven = num => num % 2 === 0;const isPositive = num => num > 0;const isPositiveOrEven = either(isPositive, isEven);isPositiveOrEven(4); // trueisPositiveOrEven(3); // true"},{"title":"elementContains","type":0,"sectionRef":"#","url":"docs/elementContains","content":"Returns true if the parent element contains the child element, false otherwise.Check that parent is not the same element as child, use parent.contains(child) to check if the parent element contains the child element.Copyconst elementContains = (parent, child) => parent !== child && parent.contains(child);CopyelementContains(document.querySelector('head'), document.querySelector('title')); // trueelementContains(document.querySelector('body'), document.querySelector('body')); // false"},{"title":"elementIsVisibleInViewport","type":0,"sectionRef":"#","url":"docs/elementIsVisibleInViewport","content":"Returns true if the element specified is visible in the viewport, false otherwise.Use Element.getBoundingClientRect() and the window.inner(Width|Height) values to determine if a given element is visible in the viewport. Omit the second argument to determine if the element is entirely visible, or specify true to determine if it is partially visible.Copyconst elementIsVisibleInViewport = (el, partiallyVisible = false) => { const { top, left, bottom, right } = el.getBoundingClientRect(); const { innerHeight, innerWidth } = window; return partiallyVisible ? ((top > 0 && top < innerHeight) || (bottom > 0 && bottom < innerHeight)) && ((left > 0 && left < innerWidth) || (right > 0 && right < innerWidth)) : top >= 0 && left >= 0 && bottom <= innerHeight && right <= innerWidth;};Copy// e.g. 100x100 viewport and a 10x10px element at position {top: -1, left: 0, bottom: 9, right: 10}elementIsVisibleInViewport(el); // false - (not fully visible)elementIsVisibleInViewport(el, true); // true - (partially visible)"},{"title":"elo","type":0,"sectionRef":"#","url":"docs/elo","content":"Computes the new ratings between two or more opponents using the Elo rating system. It takes an array of pre-ratings and returns an array containing post-ratings. The array should be ordered from best performer to worst performer (winner -> loser).Use the exponent ** operator and math operators to compute the expected score (chance of winning). of each opponent and compute the new rating for each. Loop through the ratings, using each permutation to compute the post-Elo rating for each player in a pairwise fashion. Omit the second argument to use the default kFactor of 32.Copyconst elo = ([...ratings], kFactor = 32, selfRating) => { const [a, b] = ratings; const expectedScore = (self, opponent) => 1 / (1 + 10 ** ((opponent - self) / 400)); const newRating = (rating, i) => (selfRating || rating) + kFactor * (i - expectedScore(i ? a : b, i ? b : a)); if (ratings.length === 2) return [newRating(a, 1), newRating(b, 0)]; for (let i = 0, len = ratings.length; i < len; i++) { let j = i; while (j < len - 1) { j++; [ratings[i], ratings[j]] = elo([ratings[i], ratings[j]], kFactor); } } return ratings;};Copy// Standard 1v1selo([1200, 1200]); // [1216, 1184]elo([1200, 1200], 64); // [1232, 1168]// 4 player FFA, all same rankelo([1200, 1200, 1200, 1200]).map(Math.round); // [1246, 1215, 1185, 1154]/*For teams, each rating can adjusted based on own team's average rating vs.average rating of opposing team, with the score being added to theirown individual rating by supplying it as the third argument.*/"},{"title":"equals","type":0,"sectionRef":"#","url":"docs/equals","content":"Performs a deep comparison between two values to determine if they are equivalent.Check if the two values are identical, if they are both Date objects with the same time, using Date.getTime() or if they are both non-object values with an equivalent value (strict comparison). Check if only one value is null or undefined or if their prototypes differ. If none of the above conditions are met, use Object.keys() to check if both values have the same number of keys, then use Array.prototype.every() to check if every key in the first value exists in the second one and if they are equivalent by calling this method recursively.Copyconst equals = (a, b) => { if (a === b) return true; if (a instanceof Date && b instanceof Date) return a.getTime() === b.getTime(); if (!a || !b || (typeof a !== 'object' && typeof b !== 'object')) return a === b; if (a.prototype !== b.prototype) return false; let keys = Object.keys(a); if (keys.length !== Object.keys(b).length) return false; return keys.every(k => equals(a[k], b[k]));};Copyequals({ a: [2, { e: 3 }], b: [4], c: 'foo' }, { a: [2, { e: 3 }], b: [4], c: 'foo' }); // trueequals([1, 2, 3], { 0: 1, 1: 2, 2: 3 }); // true"},{"title":"escapeHTML","type":0,"sectionRef":"#","url":"docs/escapeHTML","content":"Escapes a string for use in HTML.Use String.prototype.replace() with a regexp that matches the characters that need to be escaped, using a callback function to replace each character instance with its associated escaped character using a dictionary (object).Copyconst escapeHTML = str => str.replace( /[&<>'\"]/g, tag => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', \"'\": '&#39;', '\"': '&quot;' }[tag] || tag) );CopyescapeHTML('<a href=\"#\">Me & you</a>'); // '&lt;a href=&quot;#&quot;&gt;Me &amp; you&lt;/a&gt;'"},{"title":"escapeRegExp","type":0,"sectionRef":"#","url":"docs/escapeRegExp","content":"Escapes a string to use in a regular expression.Use String.prototype.replace() to escape special characters.Copyconst escapeRegExp = str => str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');CopyescapeRegExp('(test)'); // \\\\(test\\\\)"},{"title":"everyNth","type":0,"sectionRef":"#","url":"docs/everyNth","content":"Returns every nth element in an array.Use Array.prototype.filter() to create a new array that contains every nth element of a given array.Copyconst everyNth = (arr, nth) => arr.filter((e, i) => i % nth === nth - 1);CopyeveryNth([1, 2, 3, 4, 5, 6], 2); // [ 2, 4, 6 ]"},{"title":"expandTabs","type":0,"sectionRef":"#","url":"docs/expandTabs","content":"Convert tabs to spaces, where each tab corresponds to count spaces.Use String.prototype.replace() with a regular expression and String.prototype.repeat() to replace each tab character with count spaces.Copyconst expandTabs = (str, count) => str.replace(/\\t/g, ' '.repeat(count));CopyexpandTabs('\\t\\tlorem', 3); // ' lorem'"},{"title":"extendHex","type":0,"sectionRef":"#","url":"docs/extendHex","content":"Extends a 3-digit color code to a 6-digit color code.Use Array.prototype.map(), String.prototype.split() and Array.prototype.join() to join the mapped array for converting a 3-digit RGB notated hexadecimal color-code to the 6-digit form. Array.prototype.slice() is used to remove # from string start since it's added once.Copyconst extendHex = shortHex => '#' + shortHex .slice(shortHex.startsWith('#') ? 1 : 0) .split('') .map(x => x + x) .join('');CopyextendHex('#03f'); // '#0033ff'extendHex('05a'); // '#0055aa'"},{"title":"factorial","type":0,"sectionRef":"#","url":"docs/factorial","content":"Calculates the factorial of a number.Use recursion. If n is less than or equal to 1, return 1. Otherwise, return the product of n and the factorial of n - 1. Throws an exception if n is a negative number.Copyconst factorial = n => n < 0 ? (() => { throw new TypeError('Negative numbers are not allowed!'); })() : n <= 1 ? 1 : n * factorial(n - 1);Copyfactorial(6); // 720"},{"title":"fahrenheitToCelsius","type":0,"sectionRef":"#","url":"docs/fahrenheitToCelsius","content":"Converts Fahrenheit to Celsius.Follows the conversion formula C = (F - 32) * 5/9.Copyconst fahrenheitToCelsius = degrees => ((degrees - 32) * 5) / 9;CopyfahrenheitToCelsius(32); // 0"},{"title":"fibonacci","type":0,"sectionRef":"#","url":"docs/fibonacci","content":"Generates an array, containing the Fibonacci sequence, up until the nth term.Create an empty array of the specific length, initializing the first two values (0 and 1). Use Array.prototype.reduce() to add values into the array, using the sum of the last two values, except for the first two.Copyconst fibonacci = n => Array.from({ length: n }).reduce( (acc, val, i) => acc.concat(i > 1 ? acc[i - 1] + acc[i - 2] : i), [] );Copyfibonacci(6); // [0, 1, 1, 2, 3, 5]"},{"title":"filterNonUnique","type":0,"sectionRef":"#","url":"docs/filterNonUnique","content":"Filters out the non-unique values in an array.Use Array.prototype.filter() for an array containing only the unique values.Copyconst filterNonUnique = arr => arr.filter(i => arr.indexOf(i) === arr.lastIndexOf(i));CopyfilterNonUnique([1, 2, 2, 3, 4, 4, 5]); // [1, 3, 5]"},{"title":"filterNonUniqueBy","type":0,"sectionRef":"#","url":"docs/filterNonUniqueBy","content":"Filters out the non-unique values in an array, based on a provided comparator function.Use Array.prototype.filter() and Array.prototype.every() for an array containing only the unique values, based on the comparator function, fn. The comparator function takes four arguments: the values of the two elements being compared and their indexes.Copyconst filterNonUniqueBy = (arr, fn) => arr.filter((v, i) => arr.every((x, j) => (i === j) === fn(v, x, i, j)));CopyfilterNonUniqueBy( [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' }, { id: 1, value: 'd' }, { id: 0, value: 'e' } ], (a, b) => a.id == b.id); // [ { id: 2, value: 'c' } ]"},{"title":"findKey","type":0,"sectionRef":"#","url":"docs/findKey","content":"Returns the first key that satisfies the provided testing function. Otherwise undefined is returned.Use Object.keys(obj) to get all the properties of the object, Array.prototype.find() to test the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.Copyconst findKey = (obj, fn) => Object.keys(obj).find(key => fn(obj[key], key, obj));CopyfindKey( { barney: { age: 36, active: true }, fred: { age: 40, active: false }, pebbles: { age: 1, active: true } }, o => o['active']); // 'barney'"},{"title":"findLast","type":0,"sectionRef":"#","url":"docs/findLast","content":"Returns the last element for which the provided function returns a truthy value.Use Array.prototype.filter() to remove elements for which fn returns falsy values, Array.prototype.pop() to get the last one.Copyconst findLast = (arr, fn) => arr.filter(fn).pop();CopyfindLast([1, 2, 3, 4], n => n % 2 === 1); // 3"},{"title":"findLastIndex","type":0,"sectionRef":"#","url":"docs/findLastIndex","content":"Returns the index of the last element for which the provided function returns a truthy value.Use Array.prototype.map() to map each element to an array with its index and value. Use Array.prototype.filter() to remove elements for which fn returns falsy values, Array.prototype.pop() to get the last one. -1 is the default value when not found.Copyconst findLastIndex = (arr, fn) => (arr .map((val, i) => [i, val]) .filter(([i, val]) => fn(val, i, arr)) .pop() || [-1])[0];CopyfindLastIndex([1, 2, 3, 4], n => n % 2 === 1); // 2 (index of the value 3)findLastIndex([1, 2, 3, 4], n => n === 5); // -1 (default value when not found)"},{"title":"findLastKey","type":0,"sectionRef":"#","url":"docs/findLastKey","content":"Returns the last key that satisfies the provided testing function. Otherwise undefined is returned.Use Object.keys(obj) to get all the properties of the object, Array.prototype.reverse() to reverse their order and Array.prototype.find() to test the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.Copyconst findLastKey = (obj, fn) => Object.keys(obj) .reverse() .find(key => fn(obj[key], key, obj));CopyfindLastKey( { barney: { age: 36, active: true }, fred: { age: 40, active: false }, pebbles: { age: 1, active: true } }, o => o['active']); // 'pebbles'"},{"title":"flatten","type":0,"sectionRef":"#","url":"docs/flatten","content":"Flattens an array up to the specified depth.Use recursion, decrementing depth by 1 for each level of depth. Use Array.prototype.reduce() and Array.prototype.concat() to merge elements or arrays. Base case, for depth equal to 1 stops recursion. Omit the second argument, depth to flatten only to a depth of 1 (single flatten).Copyconst flatten = (arr, depth = 1) => arr.reduce((a, v) => a.concat(depth > 1 && Array.isArray(v) ? flatten(v, depth - 1) : v), []);Copyflatten([1, [2], 3, 4]); // [1, 2, 3, 4]flatten([1, [2, [3, [4, 5], 6], 7], 8], 2); // [1, 2, 3, [4, 5], 6, 7, 8]"},{"title":"flattenObject","type":0,"sectionRef":"#","url":"docs/flattenObject","content":"Flatten an object with the paths for keys.Use recursion. Use Object.keys(obj) combined with Array.prototype.reduce() to convert every leaf node to a flattened path node. If the value of a key is an object, the function calls itself with the appropriate prefix to create the path using Object.assign(). Otherwise, it adds the appropriate prefixed key-value pair to the accumulator object. You should always omit the second argument, prefix, unless you want every key to have a prefix.Copyconst flattenObject = (obj, prefix = '') => Object.keys(obj).reduce((acc, k) => { const pre = prefix.length ? prefix + '.' : ''; if (typeof obj[k] === 'object') Object.assign(acc, flattenObject(obj[k], pre + k)); else acc[pre + k] = obj[k]; return acc; }, {});CopyflattenObject({ a: { b: { c: 1 } }, d: 1 }); // { 'a.b.c': 1, d: 1 }"},{"title":"flip","type":0,"sectionRef":"#","url":"docs/flip","content":"Flip takes a function as an argument, then makes the first argument the last.Return a closure that takes variadic inputs, and splices the last argument to make it the first argument before applying the rest.Copyconst flip = fn => (first, ...rest) => fn(...rest, first);Copylet a = { name: 'John Smith' };let b = {};const mergeFrom = flip(Object.assign);let mergePerson = mergeFrom.bind(null, a);mergePerson(b); // == bb = {};Object.assign(b, a); // == b"},{"title":"forEachRight","type":0,"sectionRef":"#","url":"docs/forEachRight","content":"Executes a provided function once for each array element, starting from the array's last element.Use Array.prototype.slice() to clone the given array, Array.prototype.reverse() to reverse it and Array.prototype.forEach() to iterate over the reversed array.Copyconst forEachRight = (arr, callback) => arr .slice() .reverse() .forEach(callback);CopyforEachRight([1, 2, 3, 4], val => console.log(val)); // '4', '3', '2', '1'"},{"title":"forOwn","type":0,"sectionRef":"#","url":"docs/forOwn","content":"Iterates over all own properties of an object, running a callback for each one.Use Object.keys(obj) to get all the properties of the object, Array.prototype.forEach() to run the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.Copyconst forOwn = (obj, fn) => Object.keys(obj).forEach(key => fn(obj[key], key, obj));CopyforOwn({ foo: 'bar', a: 1 }, v => console.log(v)); // 'bar', 1"},{"title":"forOwnRight","type":0,"sectionRef":"#","url":"docs/forOwnRight","content":"Iterates over all own properties of an object in reverse, running a callback for each one.Use Object.keys(obj) to get all the properties of the object, Array.prototype.reverse() to reverse their order and Array.prototype.forEach() to run the provided function for each key-value pair. The callback receives three arguments - the value, the key and the object.Copyconst forOwnRight = (obj, fn) => Object.keys(obj) .reverse() .forEach(key => fn(obj[key], key, obj));CopyforOwnRight({ foo: 'bar', a: 1 }, v => console.log(v)); // 1, 'bar'"},{"title":"formToObject","type":0,"sectionRef":"#","url":"docs/formToObject","content":"Encode a set of form elements as an object.Use the FormData constructor to convert the HTML form to FormData, Array.from() to convert to an array. Collect the object from the array, using Array.prototype.reduce().Copyconst formToObject = form => Array.from(new FormData(form)).reduce( (acc, [key, value]) => ({ ...acc, [key]: value }), {} );CopyformToObject(document.querySelector('#form')); // { email: 'test@email.com', name: 'Test Name' }"},{"title":"formatDuration","type":0,"sectionRef":"#","url":"docs/formatDuration","content":"Returns the human readable format of the given number of milliseconds.Divide ms with the appropriate values to obtain the appropriate values for day, hour, minute, second and millisecond. Use Object.entries() with Array.prototype.filter() to keep only non-zero values. Use Array.prototype.map() to create the string for each value, pluralizing appropriately. Use String.prototype.join(', ') to combine the values into a string.Copyconst formatDuration = ms => { if (ms < 0) ms = -ms; const time = { day: Math.floor(ms / 86400000), hour: Math.floor(ms / 3600000) % 24, minute: Math.floor(ms / 60000) % 60, second: Math.floor(ms / 1000) % 60, millisecond: Math.floor(ms) % 1000 }; return Object.entries(time) .filter(val => val[1] !== 0) .map(([key, val]) => `${val} ${key}${val !== 1 ? 's' : ''}`) .join(', ');};CopyformatDuration(1001); // '1 second, 1 millisecond'formatDuration(34325055574); // '397 days, 6 hours, 44 minutes, 15 seconds, 574 milliseconds'"},{"title":"frequencies","type":0,"sectionRef":"#","url":"docs/frequencies","content":"Returns an object with the unique values of an array as keys and their frequencies as the values.Use Array.prototype.reduce() to map unique values to an object's keys, adding to existing keys every time the same value is encountered.Copyconst frequencies = arr => arr.reduce((a, v) => { a[v] = a[v] ? a[v] + 1 : 1; return a; }, {});Copyfrequencies(['a', 'b', 'a', 'c', 'a', 'a', 'b']); // { a: 4, b: 2, c: 1 }"},{"title":"fromCamelCase","type":0,"sectionRef":"#","url":"docs/fromCamelCase","content":"Converts a string from camelcase.Use String.prototype.replace() to remove underscores, hyphens, and spaces and convert words to camelcase. Omit the second argument to use a default separator of _.Copyconst fromCamelCase = (str, separator = '_') => str .replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2') .replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2') .toLowerCase();CopyfromCamelCase('someDatabaseFieldName', ' '); // 'some database field name'fromCamelCase('someLabelThatNeedsToBeCamelized', '-'); // 'some-label-that-needs-to-be-camelized'fromCamelCase('someJavascriptProperty', '_'); // 'some_javascript_property'"},{"title":"functionName","type":0,"sectionRef":"#","url":"docs/functionName","content":"Logs the name of a function.Use console.debug() and the name property of the passed method to log the method's name to the debug channel of the console.Copyconst functionName = fn => (console.debug(fn.name), fn);CopyfunctionName(Math.max); // max (logged in debug channel of console)"},{"title":"functions","type":0,"sectionRef":"#","url":"docs/functions","content":"Returns an array of function property names from own (and optionally inherited) enumerable properties of an object.Use Object.keys(obj) to iterate over the object's own properties. If inherited is true, use Object.get.PrototypeOf(obj) to also get the object's inherited properties. Use Array.prototype.filter() to keep only those properties that are functions. Omit the second argument, inherited, to not include inherited properties by default.Copyconst functions = (obj, inherited = false) => (inherited ? [...Object.keys(obj), ...Object.keys(Object.getPrototypeOf(obj))] : Object.keys(obj) ).filter(key => typeof obj[key] === 'function');Copyfunction Foo() { this.a = () => 1; this.b = () => 2;}Foo.prototype.c = () => 3;functions(new Foo()); // ['a', 'b']functions(new Foo(), true); // ['a', 'b', 'c']"},{"title":"gcd","type":0,"sectionRef":"#","url":"docs/gcd","content":"Calculates the greatest common divisor between two or more numbers/arrays.The inner _gcd function uses recursion. Base case is when y equals 0. In this case, return x. Otherwise, return the GCD of y and the remainder of the division x/y.Copyconst gcd = (...arr) => { const _gcd = (x, y) => (!y ? x : gcd(y, x % y)); return [...arr].reduce((a, b) => _gcd(a, b));};Copygcd(8, 36); // 4gcd(...[12, 8, 32]); // 4"},{"title":"geometricProgression","type":0,"sectionRef":"#","url":"docs/geometricProgression","content":"Initializes an array containing the numbers in the specified range where start and end are inclusive and the ratio between two terms is step. Returns an error if step equals 1.Use Array.from(), Math.log() and Math.floor() to create an array of the desired length, Array.prototype.map() to fill with the desired values in a range. Omit the second argument, start, to use a default value of 1. Omit the third argument, step, to use a default value of 2.Copyconst geometricProgression = (end, start = 1, step = 2) => Array.from({ length: Math.floor(Math.log(end / start) / Math.log(step)) + 1 }).map( (v, i) => start * step ** i );CopygeometricProgression(256); // [1, 2, 4, 8, 16, 32, 64, 128, 256]geometricProgression(256, 3); // [3, 6, 12, 24, 48, 96, 192]geometricProgression(256, 1, 4); // [1, 4, 16, 64, 256]"},{"title":"get","type":0,"sectionRef":"#","url":"docs/get","content":"Retrieve a set of properties indicated by the given selectors from an object.Use Array.prototype.map() for each selector, String.prototype.replace() to replace square brackets with dots, String.prototype.split('.') to split each selector, Array.prototype.filter() to remove empty values and Array.prototype.reduce() to get the value indicated by it.Copyconst get = (from, ...selectors) => [...selectors].map(s => s .replace(/\\[([^\\[\\]]*)\\]/g, '.$1.') .split('.') .filter(t => t !== '') .reduce((prev, cur) => prev && prev[cur], from) );Copyconst obj = { selector: { to: { val: 'val to select' } }, target: [1, 2, { a: 'test' }] };get(obj, 'selector.to.val', 'target[0]', 'target[2].a'); // ['val to select', 1, 'test']"},{"title":"getBaseURL","type":0,"sectionRef":"#","url":"docs/getBaseURL","content":"Returns the current URL without any parameters.Use String.prototype.indexOf() to check if the given url has parameters, String.prototype.slice() to remove them if necessary.Copyconst getBaseURL = url => url.indexOf('?') > 0 ? url.slice(0, url.indexOf('?')) : url;CopygetBaseURL('http://url.com/page?name=Adam&surname=Smith'); // 'http://url.com/page'"},{"title":"getColonTimeFromDate","type":0,"sectionRef":"#","url":"docs/getColonTimeFromDate","content":"Returns a string of the form HH:MM:SS from a Date object.Use Date.prototype.toTimeString() and String.prototype.slice() to get the HH:MM:SS part of a given Date object.Copyconst getColonTimeFromDate = date => date.toTimeString().slice(0, 8);CopygetColonTimeFromDate(new Date()); // \"08:38:00\""},{"title":"getDaysDiffBetweenDates","type":0,"sectionRef":"#","url":"docs/getDaysDiffBetweenDates","content":"Returns the difference (in days) between two dates.Calculate the difference (in days) between two Date objects.Copyconst getDaysDiffBetweenDates = (dateInitial, dateFinal) => (dateFinal - dateInitial) / (1000 * 3600 * 24);CopygetDaysDiffBetweenDates(new Date('2017-12-13'), new Date('2017-12-22')); // 9"},{"title":"getImages","type":0,"sectionRef":"#","url":"docs/getImages","content":"Fetches all images from within an element and puts them into an arrayUse Element.prototype.getElementsByTagName() to fetch all <img> elements inside the provided element, Array.prototype.map() to map every src attribute of their respective <img> element, then create a Set to eliminate duplicates and return the array.Copyconst getImages = (el, includeDuplicates = false) => { const images = [...el.getElementsByTagName('img')].map(img => img.getAttribute('src')); return includeDuplicates ? images : [...new Set(images)];};CopygetImages(document, true); // ['image1.jpg', 'image2.png', 'image1.png', '...']getImages(document, false); // ['image1.jpg', 'image2.png', '...']"},{"title":"getMeridiemSuffixOfInteger","type":0,"sectionRef":"#","url":"docs/getMeridiemSuffixOfInteger","content":"Converts an integer to a suffixed string, adding am or pm based on its value.Use the modulo operator (%) and conditional checks to transform an integer to a stringified 12-hour format with meridiem suffix.Copyconst getMeridiemSuffixOfInteger = num => num === 0 || num === 24 ? 12 + 'am' : num === 12 ? 12 + 'pm' : num < 12 ? (num % 12) + 'am' : (num % 12) + 'pm';CopygetMeridiemSuffixOfInteger(0); // \"12am\"getMeridiemSuffixOfInteger(11); // \"11am\"getMeridiemSuffixOfInteger(13); // \"1pm\"getMeridiemSuffixOfInteger(25); // \"1pm\""},{"title":"getScrollPosition","type":0,"sectionRef":"#","url":"docs/getScrollPosition","content":"Returns the scroll position of the current page.Use pageXOffset and pageYOffset if they are defined, otherwise scrollLeft and scrollTop. You can omit el to use a default value of window.Copyconst getScrollPosition = (el = window) => ({ x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft, y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop});CopygetScrollPosition(); // {x: 0, y: 200}"},{"title":"getStyle","type":0,"sectionRef":"#","url":"docs/getStyle","content":"Returns the value of a CSS rule for the specified element.Use Window.getComputedStyle() to get the value of the CSS rule for the specified element.Copyconst getStyle = (el, ruleName) => getComputedStyle(el)[ruleName];CopygetStyle(document.querySelector('p'), 'font-size'); // '16px'"},{"title":"getType","type":0,"sectionRef":"#","url":"docs/getType","content":"Returns the native type of a value.Return 'undefined' or 'null' if the value is undefined or null. Otherwise, use Object.prototype.constructor.name to get the name of the constructor.Copyconst getType = v => (v === undefined ? 'undefined' : v === null ? 'null' : v.constructor.name);CopygetType(new Set([1, 2, 3])); // 'Set'"},{"title":"getURLParameters","type":0,"sectionRef":"#","url":"docs/getURLParameters","content":"Returns an object containing the parameters of the current URL.Use String.prototype.match() with an appropriate regular expression to get all key-value pairs, Array.prototype.reduce() to map and combine them into a single object. Pass location.search as the argument to apply to the current url.Copyconst getURLParameters = url => (url.match(/([^?=&]+)(=([^&]*))/g) || []).reduce( (a, v) => ((a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1)), a), {} );CopygetURLParameters('http://url.com/page?name=Adam&surname=Smith'); // {name: 'Adam', surname: 'Smith'}getURLParameters('google.com'); // {}"},{"title":"groupBy","type":0,"sectionRef":"#","url":"docs/groupBy","content":"Groups the elements of an array based on the given function.Use Array.prototype.map() to map the values of an array to a function or property name. Use Array.prototype.reduce() to create an object, where the keys are produced from the mapped results.Copyconst groupBy = (arr, fn) => arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val, i) => { acc[val] = (acc[val] || []).concat(arr[i]); return acc; }, {});CopygroupBy([6.1, 4.2, 6.3], Math.floor); // {4: [4.2], 6: [6.1, 6.3]}groupBy(['one', 'two', 'three'], 'length'); // {3: ['one', 'two'], 5: ['three']}"},{"title":"hammingDistance","type":0,"sectionRef":"#","url":"docs/hammingDistance","content":"Calculates the Hamming distance between two values.Use the XOR operator (^) to find the bit difference between the two numbers, convert to a binary string using toString(2). Count and return the number of 1s in the string, using match(/1/g).Copyconst hammingDistance = (num1, num2) => ((num1 ^ num2).toString(2).match(/1/g) || '').length;CopyhammingDistance(2, 3); // 1"},{"title":"hasClass","type":0,"sectionRef":"#","url":"docs/hasClass","content":"Returns true if the element has the specified class, false otherwise.Use element.classList.contains() to check if the element has the specified class.Copyconst hasClass = (el, className) => el.classList.contains(className);CopyhasClass(document.querySelector('p.special'), 'special'); // true"},{"title":"hasFlags","type":0,"sectionRef":"#","url":"docs/hasFlags","content":"Check if the current process's arguments contain the specified flags.Use Array.prototype.every() and Array.prototype.includes() to check if process.argv contains all the specified flags. Use a regular expression to test if the specified flags are prefixed with - or -- and prefix them accordingly.Copyconst hasFlags = (...flags) => flags.every(flag => process.argv.includes(/^-{1,2}/.test(flag) ? flag : '--' + flag));Copy// node myScript.js -s --test --cool=truehasFlags('-s'); // truehasFlags('--test', 'cool=true', '-s'); // truehasFlags('special'); // false"},{"title":"hasKey","type":0,"sectionRef":"#","url":"docs/hasKey","content":"Returns true if the target value exists in a JSON object, false otherwise.Check if keys is non-empty and use Array.prototype.every() to sequentially check its keys to internal depth of the object, obj. Use Object.prototype.hasOwnProperty() to check if obj does not have the current key or is not an object, stop propagation and return false. Otherwise assign the key's value to obj to use on the next iteration. Return false beforehand if given key list is empty.Copyconst hasKey = (obj, keys) => { return ( keys.length > 0 && keys.every(key => { if (typeof obj !== 'object' || !obj.hasOwnProperty(key)) return false; obj = obj[key]; return true; }) );};Copylet obj = { a: 1, b: { c: 4 }, 'b.d': 5};hasKey(obj, ['a']); // truehasKey(obj, ['b']); // truehasKey(obj, ['b', 'c']); // truehasKey(obj, ['b.d']); // truehasKey(obj, ['d']); // falsehasKey(obj, ['c']); // falsehasKey(obj, ['b', 'f']); // false"},{"title":"hashBrowser","type":0,"sectionRef":"#","url":"docs/hashBrowser","content":"Creates a hash for a value using the SHA-256 algorithm. Returns a promise.Use the SubtleCrypto API to create a hash for the given value.Copyconst hashBrowser = val => crypto.subtle.digest('SHA-256', new TextEncoder('utf-8').encode(val)).then(h => { let hexes = [], view = new DataView(h); for (let i = 0; i < view.byteLength; i += 4) hexes.push(('00000000' + view.getUint32(i).toString(16)).slice(-8)); return hexes.join(''); });CopyhashBrowser(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'"},{"title":"hashNode","type":0,"sectionRef":"#","url":"docs/hashNode","content":"Creates a hash for a value using the SHA-256 algorithm. Returns a promise.Use crypto API to create a hash for the given value, setTimeout to prevent blocking on a long operation, and a Promise to give it a familiar interface.Copyconst crypto = require('crypto');const hashNode = val => new Promise(resolve => setTimeout( () => resolve( crypto .createHash('sha256') .update(val) .digest('hex') ), 0 ) );CopyhashNode(JSON.stringify({ a: 'a', b: [1, 2, 3, 4], foo: { c: 'bar' } })).then(console.log); // '04aa106279f5977f59f9067fa9712afc4aedc6f5862a8defc34552d8c7206393'"},{"title":"haveSameContents","type":0,"sectionRef":"#","url":"docs/haveSameContents","content":"Returns true if two arrays contain the same elements regardless of order, false otherwise.Use a for...of loop over a Set created from the values of both arrays. Use Array.prototype.filter() to compare the amount of occurrences of each distinct value in both arrays. Return false if the counts do not match for any element, true otherwise.Copyconst haveSameContents = (a, b) => { for (const v of new Set([...a, ...b])) if (a.filter(e => e === v).length !== b.filter(e => e === v).length) return false; return true;};CopyhaveSameContents([1, 2, 4], [2, 4, 1]); // true"},{"title":"head","type":0,"sectionRef":"#","url":"docs/head","content":"Returns the head of a list.Check if arr is truthy and has a length property, use arr[0] if possible to return the first element, otherwise return undefined.Copyconst head = arr => (arr && arr.length ? arr[0] : undefined);Copyhead([1, 2, 3]); // 1head([]); // undefinedhead(null); // undefinedhead(undefined); // undefined"},{"title":"hexToRGB","type":0,"sectionRef":"#","url":"docs/hexToRGB","content":"Converts a color code to a rgb() or rgba() string if alpha value is provided.Use bitwise right-shift operator and mask bits with & (and) operator to convert a hexadecimal color code (with or without prefixed with #) to a string with the RGB values. If it's 3-digit color code, first convert to 6-digit version. If an alpha value is provided alongside 6-digit hex, give rgba() string in return.Copyconst hexToRGB = hex => { let alpha = false, h = hex.slice(hex.startsWith('#') ? 1 : 0); if (h.length === 3) h = [...h].map(x => x + x).join(''); else if (h.length === 8) alpha = true; h = parseInt(h, 16); return ( 'rgb' + (alpha ? 'a' : '') + '(' + (h >>> (alpha ? 24 : 16)) + ', ' + ((h & (alpha ? 0x00ff0000 : 0x00ff00)) >>> (alpha ? 16 : 8)) + ', ' + ((h & (alpha ? 0x0000ff00 : 0x0000ff)) >>> (alpha ? 8 : 0)) + (alpha ? `, ${h & 0x000000ff}` : '') + ')' );};CopyhexToRGB('#27ae60ff'); // 'rgba(39, 174, 96, 255)'hexToRGB('27ae60'); // 'rgb(39, 174, 96)'hexToRGB('#fff'); // 'rgb(255, 255, 255)'"},{"title":"hide","type":0,"sectionRef":"#","url":"docs/hide","content":"Hides all the elements specified.Use NodeList.prototype.forEach() to apply display: none to each element specified.Copyconst hide = (...el) => [...el].forEach(e => (e.style.display = 'none'));Copyhide(document.querySelectorAll('img')); // Hides all <img> elements on the page"},{"title":"httpDelete","type":0,"sectionRef":"#","url":"docs/httpDelete","content":"Makes a DELETE request to the passed URL.Use XMLHttpRequest web api to make a delete request to the given url. Handle the onload event, by running the provided callback function. Handle the onerror event, by running the provided err function. Omit the third argument, err to log the request to the console's error stream by default.Copyconst httpDelete = (url, callback, err = console.error) => { const request = new XMLHttpRequest(); request.open('DELETE', url, true); request.onload = () => callback(request); request.onerror = () => err(request); request.send();};CopyhttpDelete('https://jsonplaceholder.typicode.com/posts/1', request => { console.log(request.responseText);}); /*Logs: {}*/"},{"title":"httpGet","type":0,"sectionRef":"#","url":"docs/httpGet","content":"Makes a GET request to the passed URL.Use XMLHttpRequest web api to make a get request to the given url. Handle the onload event, by calling the given callback the responseText. Handle the onerror event, by running the provided err function. Omit the third argument, err, to log errors to the console's error stream by default.Copyconst httpGet = (url, callback, err = console.error) => { const request = new XMLHttpRequest(); request.open('GET', url, true); request.onload = () => callback(request.responseText); request.onerror = () => err(request); request.send();};CopyhttpGet( 'https://jsonplaceholder.typicode.com/posts/1', console.log); /*Logs: { \"userId\": 1, \"id\": 1, \"title\": \"sunt aut facere repellat provident occaecati excepturi optio reprehenderit\", \"body\": \"quia et suscipit\\nsuscipit recusandae consequuntur expedita et cum\\nreprehenderit molestiae ut ut quas totam\\nnostrum rerum est autem sunt rem eveniet architecto\"}*/"},{"title":"httpPost","type":0,"sectionRef":"#","url":"docs/httpPost","content":"Makes a POST request to the passed URL.Use XMLHttpRequest web api to make a post request to the given url. Set the value of an HTTP request header with setRequestHeader method. Handle the onload event, by calling the given callback the responseText. Handle the onerror event, by running the provided err function. Omit the third argument, data, to send no data to the provided url. Omit the fourth argument, err, to log errors to the console's error stream by default.Copyconst httpPost = (url, data, callback, err = console.error) => { const request = new XMLHttpRequest(); request.open('POST', url, true); request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); request.onload = () => callback(request.responseText); request.onerror = () => err(request); request.send(data);};Copyconst newPost = { userId: 1, id: 1337, title: 'Foo', body: 'bar bar bar'};const data = JSON.stringify(newPost);httpPost( 'https://jsonplaceholder.typicode.com/posts', data, console.log); /*Logs: { \"userId\": 1, \"id\": 1337, \"title\": \"Foo\", \"body\": \"bar bar bar\"}*/httpPost( 'https://jsonplaceholder.typicode.com/posts', null, // does not send a body console.log); /*Logs: { \"id\": 101}*/"},{"title":"httpPut","type":0,"sectionRef":"#","url":"docs/httpPut","content":"Makes a PUT request to the passed URL.Use XMLHttpRequest web api to make a put request to the given url. Set the value of an HTTP request header with setRequestHeader method. Handle the onload event, by running the provided callback function. Handle the onerror event, by running the provided err function. Omit the last argument, err to log the request to the console's error stream by default.Copyconst httpPut = (url, data, callback, err = console.error) => { const request = new XMLHttpRequest(); request.open('PUT', url, true); request.setRequestHeader('Content-type', 'application/json; charset=utf-8'); request.onload = () => callback(request); request.onerror = () => err(request); request.send(data);};Copyconst password = 'fooBaz';const data = JSON.stringify({ id: 1, title: 'foo', body: 'bar', userId: 1});httpPut('https://jsonplaceholder.typicode.com/posts/1', data, request => { console.log(request.responseText);}); /*Logs: { id: 1, title: 'foo', body: 'bar', userId: 1}*/"},{"title":"httpsRedirect","type":0,"sectionRef":"#","url":"docs/httpsRedirect","content":"Redirects the page to HTTPS if its currently in HTTP. Also, pressing the back button doesn't take it back to the HTTP page as its replaced in the history.Use location.protocol to get the protocol currently being used. If it's not HTTPS, use location.replace() to replace the existing page with the HTTPS version of the page. Use location.href to get the full address, split it with String.prototype.split() and remove the protocol part of the URL.Copyconst httpsRedirect = () => { if (location.protocol !== 'https:') location.replace('https://' + location.href.split('//')[1]);};CopyhttpsRedirect(); // If you are on http://mydomain.com, you are redirected to https://mydomain.com"},{"title":"hz","type":0,"sectionRef":"#","url":"docs/hz","content":"Returns the number of times a function executed per second. hz is the unit for hertz, the unit of frequency defined as one cycle per second.Use performance.now() to get the difference in milliseconds before and after the iteration loop to calculate the time elapsed executing the function iterations times. Return the number of cycles per second by converting milliseconds to seconds and dividing it by the time elapsed. Omit the second argument, iterations, to use the default of 100 iterations.Copyconst hz = (fn, iterations = 100) => { const before = performance.now(); for (let i = 0; i < iterations; i++) fn(); return (1000 * iterations) / (performance.now() - before);};Copy// 10,000 element arrayconst numbers = Array(10000) .fill() .map((_, i) => i); // Test functions with the same goal: sum up the elements in the arrayconst sumReduce = () => numbers.reduce((acc, n) => acc + n, 0);const sumForLoop = () => { let sum = 0; for (let i = 0; i < numbers.length; i++) sum += numbers[i]; return sum;}; // `sumForLoop` is nearly 10 times fasterMath.round(hz(sumReduce)); // 572Math.round(hz(sumForLoop)); // 4784"},{"title":"inRange","type":0,"sectionRef":"#","url":"docs/inRange","content":"Checks if the given number falls within the given range.Use arithmetic comparison to check if the given number is in the specified range. If the second parameter, end, is not specified, the range is considered to be from 0 to start.Copyconst inRange = (n, start, end = null) => { if (end && start > end) [end, start] = [start, end]; return end == null ? n >= 0 && n < start : n >= start && n < end;};CopyinRange(3, 2, 5); // trueinRange(3, 4); // trueinRange(2, 3, 5); // falseinRange(3, 2); // false"},{"title":"includesAll","type":0,"sectionRef":"#","url":"docs/includesAll","content":"Returns true if all the elements in values are included in arr, false otherwise.Use Array.prototype.every() and Array.prototype.includes() to check if all elements of values are included in arr.Copyconst includesAll = (arr, values) => values.every(v => arr.includes(v));CopyincludesAll([1, 2, 3, 4], [1, 4]); // trueincludesAll([1, 2, 3, 4], [1, 5]); // false"},{"title":"includesAny","type":0,"sectionRef":"#","url":"docs/includesAny","content":"Returns true if at least one element of values is included in arr , false otherwise.Use Array.prototype.some() and Array.prototype.includes() to check if at least one element of values is included in arr.Copyconst includesAny = (arr, values) => values.some(v => arr.includes(v));CopyincludesAny([1, 2, 3, 4], [2, 9]); // trueincludesAny([1, 2, 3, 4], [8, 9]); // false"},{"title":"indentString","type":0,"sectionRef":"#","url":"docs/indentString","content":"Indents each line in the provided string.Use String.replace and a regular expression to add the character specified by indent count times at the start of each line. Omit the third parameter, indent, to use a default indentation character of ' '.Copyconst indentString = (str, count, indent = ' ') => str.replace(/^/gm, indent.repeat(count));CopyindentString('Lorem\\nIpsum', 2); // ' Lorem\\n Ipsum'indentString('Lorem\\nIpsum', 2, '_'); // '__Lorem\\n__Ipsum'"},{"title":"indexOfAll","type":0,"sectionRef":"#","url":"docs/indexOfAll","content":"Returns all indices of val in an array. If val never occurs, returns [].Use Array.prototype.reduce() to loop over elements and store indices for matching elements. Return the array of indices.Copyconst indexOfAll = (arr, val) => arr.reduce((acc, el, i) => (el === val ? [...acc, i] : acc), []);CopyindexOfAll([1, 2, 3, 1, 2, 3], 1); // [0, 3]indexOfAll([1, 2, 3], 4); // []"},{"title":"initial","type":0,"sectionRef":"#","url":"docs/initial","content":"Returns all the elements of an array except the last one.Use arr.slice(0,-1) to return all but the last element of the array.Copyconst initial = arr => arr.slice(0, -1);Copyinitial([1, 2, 3]); // [1,2]"},{"title":"initialize2DArray","type":0,"sectionRef":"#","url":"docs/initialize2DArray","content":"Initializes a 2D array of given width and height and value.Use Array.prototype.map() to generate h rows where each is a new array of size w initialize with value. If the value is not provided, default to null.Copyconst initialize2DArray = (w, h, val = null) => Array.from({ length: h }).map(() => Array.from({ length: w }).fill(val));Copyinitialize2DArray(2, 2, 0); // [[0,0], [0,0]]"},{"title":"initializeArrayWithRange","type":0,"sectionRef":"#","url":"docs/initializeArrayWithRange","content":"Initializes an array containing the numbers in the specified range where start and end are inclusive with their common difference step.Use Array.from() to create an array of the desired length, (end - start + 1)/step, and a map function to fill it with the desired values in the given range. You can omit start to use a default value of 0. You can omit step to use a default value of 1.Copyconst initializeArrayWithRange = (end, start = 0, step = 1) => Array.from({ length: Math.ceil((end - start + 1) / step) }, (v, i) => i * step + start);CopyinitializeArrayWithRange(5); // [0,1,2,3,4,5]initializeArrayWithRange(7, 3); // [3,4,5,6,7]initializeArrayWithRange(9, 0, 2); // [0,2,4,6,8]"},{"title":"initializeArrayWithRangeRight","type":0,"sectionRef":"#","url":"docs/initializeArrayWithRangeRight","content":"Initializes an array containing the numbers in the specified range (in reverse) where start and end are inclusive with their common difference step.Use Array.from(Math.ceil((end+1-start)/step)) to create an array of the desired length(the amounts of elements is equal to (end-start)/step or (end+1-start)/step for inclusive end), Array.prototype.map() to fill with the desired values in a range. You can omit start to use a default value of 0. You can omit step to use a default value of 1.Copyconst initializeArrayWithRangeRight = (end, start = 0, step = 1) => Array.from({ length: Math.ceil((end + 1 - start) / step) }).map( (v, i, arr) => (arr.length - i - 1) * step + start );CopyinitializeArrayWithRangeRight(5); // [5,4,3,2,1,0]initializeArrayWithRangeRight(7, 3); // [7,6,5,4,3]initializeArrayWithRangeRight(9, 0, 2); // [8,6,4,2,0]"},{"title":"initializeArrayWithValues","type":0,"sectionRef":"#","url":"docs/initializeArrayWithValues","content":"Initializes and fills an array with the specified values.Use Array(n) to create an array of the desired length, fill(v) to fill it with the desired values. You can omit val to use a default value of 0.Copyconst initializeArrayWithValues = (n, val = 0) => Array(n).fill(val);CopyinitializeArrayWithValues(5, 2); // [2, 2, 2, 2, 2]"},{"title":"initializeNDArray","type":0,"sectionRef":"#","url":"docs/initializeNDArray","content":"Create a n-dimensional array with given value.Use recursion. Use Array.prototype.map() to generate rows where each is a new array initialized using initializeNDArray.Copyconst initializeNDArray = (val, ...args) => args.length === 0 ? val : Array.from({ length: args[0] }).map(() => initializeNDArray(val, ...args.slice(1)));CopyinitializeNDArray(1, 3); // [1,1,1]initializeNDArray(5, 2, 2, 2); // [[[5,5],[5,5]],[[5,5],[5,5]]]"},{"title":"insertAfter","type":0,"sectionRef":"#","url":"docs/insertAfter","content":"Inserts an HTML string after the end of the specified element.Use el.insertAdjacentHTML() with a position of 'afterend' to parse htmlString and insert it after the end of el.Copyconst insertAfter = (el, htmlString) => el.insertAdjacentHTML('afterend', htmlString);CopyinsertAfter(document.getElementById('myId'), '<p>after</p>');// <div id=\"myId\">...</div> <p>after</p>"},{"title":"insertAt","type":0,"sectionRef":"#","url":"docs/insertAt","content":"Mutates the original array to insert the given values at the specified index.Use Array.prototype.splice() with an appropriate index and a delete count of 0, spreading the given values to be inserted.Copyconst insertAt = (arr, i, ...v) => { arr.splice(i + 1, 0, ...v); return arr;};Copylet myArray = [1, 2, 3, 4];insertAt(myArray, 2, 5); // myArray = [1, 2, 3, 5, 4] let otherArray = [2, 10];insertAt(otherArray, 0, 4, 6, 8); // otherArray = [2, 4, 6, 8, 10]"},{"title":"insertBefore","type":0,"sectionRef":"#","url":"docs/insertBefore","content":"Inserts an HTML string before the start of the specified element.Use el.insertAdjacentHTML() with a position of 'beforebegin' to parse htmlString and insert it before the start of el.Copyconst insertBefore = (el, htmlString) => el.insertAdjacentHTML('beforebegin', htmlString);CopyinsertBefore(document.getElementById('myId'), '<p>before</p>');// <p>before</p> <div id=\"myId\">...</div>"},{"title":"intersection","type":0,"sectionRef":"#","url":"docs/intersection","content":"Returns a list of elements that exist in both arrays.Create a Set from b, then use Array.prototype.filter() on a to only keep values contained in b.Copyconst intersection = (a, b) => { const s = new Set(b); return [...new Set(a)].filter(x => s.has(x));};Copyintersection([1, 2, 3], [4, 3, 2]); // [2, 3]"},{"title":"intersectionBy","type":0,"sectionRef":"#","url":"docs/intersectionBy","content":"Returns a list of elements that exist in both arrays, after applying the provided function to each array element of both.Create a Set by applying fn to all elements in b, then use Array.prototype.filter() on a to only keep elements, which produce values contained in b when fn is applied to them.Copyconst intersectionBy = (a, b, fn) => { const s = new Set(b.map(fn)); return [...new Set(a)].filter(x => s.has(fn(x)));};CopyintersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [2.1]"},{"title":"intersectionWith","type":0,"sectionRef":"#","url":"docs/intersectionWith","content":"Returns a list of elements that exist in both arrays, using a provided comparator function.Use Array.prototype.filter() and Array.prototype.findIndex() in combination with the provided comparator to determine intersecting values.Copyconst intersectionWith = (a, b, comp) => a.filter(x => b.findIndex(y => comp(x, y)) !== -1);CopyintersectionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1.5, 3, 0]"},{"title":"invertKeyValues","type":0,"sectionRef":"#","url":"docs/invertKeyValues","content":"Inverts the key-value pairs of an object, without mutating it. The corresponding inverted value of each inverted key is an array of keys responsible for generating the inverted value. If a function is supplied, it is applied to each inverted key.Use Object.keys() and Array.prototype.reduce() to invert the key-value pairs of an object and apply the function provided (if any). Omit the second argument, fn, to get the inverted keys without applying a function to them.Copyconst invertKeyValues = (obj, fn) => Object.keys(obj).reduce((acc, key) => { const val = fn ? fn(obj[key]) : obj[key]; acc[val] = acc[val] || []; acc[val].push(key); return acc; }, {});CopyinvertKeyValues({ a: 1, b: 2, c: 1 }); // { 1: [ 'a', 'c' ], 2: [ 'b' ] }invertKeyValues({ a: 1, b: 2, c: 1 }, value => 'group' + value); // { group1: [ 'a', 'c' ], group2: [ 'b' ] }"},{"title":"is","type":0,"sectionRef":"#","url":"docs/is","content":"Checks if the provided value is of the specified type.Ensure the value is not undefined or null using Array.prototype.includes(), and compare the constructor property on the value with type to check if the provided value is of the specified type.Copyconst is = (type, val) => ![, null].includes(val) && val.constructor === type;Copyis(Array, [1]); // trueis(ArrayBuffer, new ArrayBuffer()); // trueis(Map, new Map()); // trueis(RegExp, /./g); // trueis(Set, new Set()); // trueis(WeakMap, new WeakMap()); // trueis(WeakSet, new WeakSet()); // trueis(String, ''); // trueis(String, new String('')); // trueis(Number, 1); // trueis(Number, new Number(1)); // trueis(Boolean, true); // trueis(Boolean, new Boolean(true)); // true"},{"title":"isAbsoluteURL","type":0,"sectionRef":"#","url":"docs/isAbsoluteURL","content":"Returns true if the given string is an absolute URL, false otherwise.Use a regular expression to test if the string is an absolute URL.Copyconst isAbsoluteURL = str => /^[a-z][a-z0-9+.-]*:/.test(str);CopyisAbsoluteURL('https://google.com'); // trueisAbsoluteURL('ftp://www.myserver.net'); // trueisAbsoluteURL('/foo/bar'); // false"},{"title":"isAfterDate","type":0,"sectionRef":"#","url":"docs/isAfterDate","content":"Check if a date is after another date.Use the greater than operator (>) to check if the first date comes after the second one.Copyconst isAfterDate = (dateA, dateB) => dateA > dateB;CopyisAfterDate(new Date(2010, 10, 21), new Date(2010, 10, 20)); // true"},{"title":"isAnagram","type":0,"sectionRef":"#","url":"docs/isAnagram","content":"Checks if a string is an anagram of another string (case-insensitive, ignores spaces, punctuation and special characters).Use String.prototype.toLowerCase(), String.prototype.replace() with an appropriate regular expression to remove unnecessary characters, String.prototype.split(''), Array.prototype.sort() and Array.prototype.join('') on both strings to normalize them, then check if their normalized forms are equal.Copyconst isAnagram = (str1, str2) => { const normalize = str => str .toLowerCase() .replace(/[^a-z0-9]/gi, '') .split('') .sort() .join(''); return normalize(str1) === normalize(str2);};CopyisAnagram('iceman', 'cinema'); // true"},{"title":"isArrayLike","type":0,"sectionRef":"#","url":"docs/isArrayLike","content":"Checks if the provided argument is array-like (i.e. is iterable).Check if the provided argument is not null and that its Symbol.iterator property is a function.Copyconst isArrayLike = obj => obj != null && typeof obj[Symbol.iterator] === 'function';CopyisArrayLike([1, 2, 3]); // trueisArrayLike(document.querySelectorAll('.className')); // trueisArrayLike('abc'); // trueisArrayLike(null); // false"},{"title":"isBeforeDate","type":0,"sectionRef":"#","url":"docs/isBeforeDate","content":"Check if a date is before another date.Use the less than operator (<) to check if the first date comes before the second one.Copyconst isBeforeDate = (dateA, dateB) => dateA < dateB;CopyisBeforeDate(new Date(2010, 10, 20), new Date(2010, 10, 21)); // true"},{"title":"isBoolean","type":0,"sectionRef":"#","url":"docs/isBoolean","content":"Checks if the given argument is a native boolean element.Use typeof to check if a value is classified as a boolean primitive.Copyconst isBoolean = val => typeof val === 'boolean';CopyisBoolean(null); // falseisBoolean(false); // true"},{"title":"isBrowser","type":0,"sectionRef":"#","url":"docs/isBrowser","content":"Determines if the current runtime environment is a browser so that front-end modules can run on the server (Node) without throwing errors.Use Array.prototype.includes() on the typeof values of both window and document (globals usually only available in a browser environment unless they were explicitly defined), which will return true if one of them is undefined. typeof allows globals to be checked for existence without throwing a ReferenceError. If both of them are not undefined, then the current environment is assumed to be a browser.Copyconst isBrowser = () => ![typeof window, typeof document].includes('undefined');CopyisBrowser(); // true (browser)isBrowser(); // false (Node)"},{"title":"isBrowserTabFocused","type":0,"sectionRef":"#","url":"docs/isBrowserTabFocused","content":"Returns true if the browser tab of the page is focused, false otherwise.Use the Document.hidden property, introduced by the Page Visibility API to check if the browser tab of the page is visible or hidden.Copyconst isBrowserTabFocused = () => !document.hidden;CopyisBrowserTabFocused(); // true"},{"title":"isContainedIn","type":0,"sectionRef":"#","url":"docs/isContainedIn","content":"Returns true if the elements of the first array are contained in the second one regardless of order, false otherwise.Use a for...of loop over a Set created from the first array. Use Array.prototype.some() to check if all distinct values are contained in the second array, use Array.prototype.filter() to compare the number of occurrences of each distinct value in both arrays. Return false if the count of any element is greater in the first array than the second one, true otherwise.Copyconst isContainedIn = (a, b) => { for (const v of new Set(a)) { if (!b.some(e => e === v) || a.filter(e => e === v).length > b.filter(e => e === v).length) return false; } return true;};CopyisContainedIn([1, 4], [2, 4, 1]); // true"},{"title":"isDivisible","type":0,"sectionRef":"#","url":"docs/isDivisible","content":"Checks if the first numeric argument is divisible by the second one.Use the modulo operator (%) to check if the remainder is equal to 0.Copyconst isDivisible = (dividend, divisor) => dividend % divisor === 0;CopyisDivisible(6, 3); // true"},{"title":"isDuplexStream","type":0,"sectionRef":"#","url":"docs/isDuplexStream","content":"Checks if the given argument is a duplex (readable and writable) stream.Check if the value is different from null, use typeof to check if a value is of type object and the pipe property is of type function. Additionally check if the typeof the _read, _write and _readableState, _writableState properties are function and object respectively.Copyconst isDuplexStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val._read === 'function' && typeof val._readableState === 'object' && typeof val._write === 'function' && typeof val._writableState === 'object';Copyconst Stream = require('stream');isDuplexStream(new Stream.Duplex()); // true"},{"title":"isEmpty","type":0,"sectionRef":"#","url":"docs/isEmpty","content":"Returns true if the a value is an empty object, collection, has no enumerable properties or is any type that is not considered a collection.Check if the provided value is null or if its length is equal to 0.Copyconst isEmpty = val => val == null || !(Object.keys(val) || val).length;CopyisEmpty([]); // trueisEmpty({}); // trueisEmpty(''); // trueisEmpty([1, 2]); // falseisEmpty({ a: 1, b: 2 }); // falseisEmpty('text'); // falseisEmpty(123); // true - type is not considered a collectionisEmpty(true); // true - type is not considered a collection"},{"title":"isEven","type":0,"sectionRef":"#","url":"docs/isEven","content":"Returns true if the given number is even, false otherwise.Checks whether a number is odd or even using the modulo (%) operator. Returns true if the number is even, false if the number is odd.Copyconst isEven = num => num % 2 === 0;CopyisEven(3); // false"},{"title":"isFunction","type":0,"sectionRef":"#","url":"docs/isFunction","content":"Checks if the given argument is a function.Use typeof to check if a value is classified as a function primitive.Copyconst isFunction = val => typeof val === 'function';CopyisFunction('x'); // falseisFunction(x => x); // true"},{"title":"isLeapYear","type":0,"sectionRef":"#","url":"docs/isLeapYear","content":"Returns true if the given year is a leap year, false otherwise.Use new Date(), setting the date to February 29th of the given year and use Date.prototype.getMonth() to check if the month is equal to 1.Copyconst isLeapYear = year => new Date(year, 1, 29).getMonth() === 1;CopyisLeapYear(2019); // falseisLeapYear(2020); // true"},{"title":"isLowerCase","type":0,"sectionRef":"#","url":"docs/isLowerCase","content":"Checks if a string is lower case.Convert the given string to lower case, using String.toLowerCase() and compare it to the original.Copyconst isLowerCase = str => str === str.toLowerCase();CopyisLowerCase('abc'); // trueisLowerCase('a3@$'); // trueisLowerCase('Ab4'); // false"},{"title":"isNegativeZero","type":0,"sectionRef":"#","url":"docs/isNegativeZero","content":"Checks if the given value is equal to negative zero (-0).Checks whether a passed value is equal to 0 and if 1 divided by the value equals -Infinity.Copyconst isNegativeZero = val => val === 0 && 1 / val === -Infinity;CopyisNegativeZero(-0); // trueisNegativeZero(0); // false"},{"title":"isNil","type":0,"sectionRef":"#","url":"docs/isNil","content":"Returns true if the specified value is null or undefined, false otherwise.Use the strict equality operator to check if the value of val is equal to null or undefined.Copyconst isNil = val => val === undefined || val === null;CopyisNil(null); // trueisNil(undefined); // trueisNil(''); // false"},{"title":"isNull","type":0,"sectionRef":"#","url":"docs/isNull","content":"Returns true if the specified value is null, false otherwise.Use the strict equality operator to check if the value of val is equal to null.Copyconst isNull = val => val === null;CopyisNull(null); // true"},{"title":"isNumber","type":0,"sectionRef":"#","url":"docs/isNumber","content":"Checks if the given argument is a number.Use typeof to check if a value is classified as a number primitive. To safeguard against NaN, check if val === val (as NaN has a typeof equal to number and is the only value not equal to itself).Copyconst isNumber = val => typeof val === 'number' && val === val;CopyisNumber(1); // trueisNumber('1'); // falseisNumber(NaN); // false"},{"title":"isObject","type":0,"sectionRef":"#","url":"docs/isObject","content":"Returns a boolean determining if the passed value is an object or not.Uses the Object constructor to create an object wrapper for the given value. If the value is null or undefined, create and return an empty object. Οtherwise, return an object of a type that corresponds to the given value.Copyconst isObject = obj => obj === Object(obj);CopyisObject([1, 2, 3, 4]); // trueisObject([]); // trueisObject(['Hello!']); // trueisObject({ a: 1 }); // trueisObject({}); // trueisObject(true); // false"},{"title":"isObjectLike","type":0,"sectionRef":"#","url":"docs/isObjectLike","content":"Checks if a value is object-like.Check if the provided value is not null and its typeof is equal to 'object'.Copyconst isObjectLike = val => val !== null && typeof val === 'object';CopyisObjectLike({}); // trueisObjectLike([1, 2, 3]); // trueisObjectLike(x => x); // falseisObjectLike(null); // false"},{"title":"isOdd","type":0,"sectionRef":"#","url":"docs/isOdd","content":"Returns true if the given number is odd, false otherwise.Checks whether a number is odd or even using the modulo (%) operator. Returns true if the number is odd, false if the number is even.Copyconst isOdd = num => num % 2 === 1;CopyisOdd(3); // true"},{"title":"isPlainObject","type":0,"sectionRef":"#","url":"docs/isPlainObject","content":"Checks if the provided value is an object created by the Object constructor.Check if the provided value is truthy, use typeof to check if it is an object and Object.constructor to make sure the constructor is equal to Object.Copyconst isPlainObject = val => !!val && typeof val === 'object' && val.constructor === Object;CopyisPlainObject({ a: 1 }); // trueisPlainObject(new Map()); // false"},{"title":"isPowerOfTwo","type":0,"sectionRef":"#","url":"docs/isPowerOfTwo","content":"Returns true if the given number is a power of 2, false otherwise.Use the bitwise binary AND operator (&) to determine if n is a power of 2. Additionally, check that n is not falsy.Copyconst isPowerOfTwo = n => !!n && (n & (n - 1)) == 0;CopyisPowerOfTwo(0); // falseisPowerOfTwo(1); // trueisPowerOfTwo(8); // true"},{"title":"isPrime","type":0,"sectionRef":"#","url":"docs/isPrime","content":"Checks if the provided integer is a prime number.Check numbers from 2 to the square root of the given number. Return false if any of them divides the given number, else return true, unless the number is less than 2.Copyconst isPrime = num => { const boundary = Math.floor(Math.sqrt(num)); for (var i = 2; i <= boundary; i++) if (num % i === 0) return false; return num >= 2;};CopyisPrime(11); // true"},{"title":"isPrimitive","type":0,"sectionRef":"#","url":"docs/isPrimitive","content":"Returns a boolean determining if the passed value is primitive or not.Create an object from val and compare it with val to determine if the passed value is primitive (i.e. not equal to the created object).Copyconst isPrimitive = val => Object(val) !== val;CopyisPrimitive(null); // trueisPrimitive(undefined); // trueisPrimitive(50); // trueisPrimitive('Hello!'); // trueisPrimitive(false); // trueisPrimitive(Symbol()); // trueisPrimitive([]); // falseisPrimitive({}); // false"},{"title":"isPromiseLike","type":0,"sectionRef":"#","url":"docs/isPromiseLike","content":"Returns true if an object looks like a Promise, false otherwise.Check if the object is not null, its typeof matches either object or function and if it has a .then property, which is also a function.Copyconst isPromiseLike = obj => obj !== null && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';CopyisPromiseLike({ then: function() { return ''; }}); // trueisPromiseLike(null); // falseisPromiseLike({}); // false"},{"title":"isReadableStream","type":0,"sectionRef":"#","url":"docs/isReadableStream","content":"Checks if the given argument is a readable stream.Check if the value is different from null, use typeof to check if the value is of type object and the pipe property is of type function. Additionally check if the typeof the _read and _readableState properties are function and object respectively.Copyconst isReadableStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val._read === 'function' && typeof val._readableState === 'object';Copyconst fs = require('fs');isReadableStream(fs.createReadStream('test.txt')); // true"},{"title":"isSameDate","type":0,"sectionRef":"#","url":"docs/isSameDate","content":"Check if a date is the same as another date.Use Date.prototype.toISOString() and strict equality checking (===) to check if the first date is the same as the second one.Copyconst isSameDate = (dateA, dateB) => dateA.toISOString() === dateB.toISOString();CopyisSameDate(new Date(2010, 10, 20), new Date(2010, 10, 20)); // true"},{"title":"isSorted","type":0,"sectionRef":"#","url":"docs/isSorted","content":"Returns 1 if the array is sorted in ascending order, -1 if it is sorted in descending order or 0 if it is not sorted.Calculate the ordering direction for the first two elements. Use Object.entries() to loop over array objects and compare them in pairs. Return 0 if the direction changes or the direction if the last element is reached.Copyconst isSorted = arr => { let direction = -(arr[0] - arr[1]); for (let [i, val] of arr.entries()) { direction = !direction ? -(arr[i - 1] - arr[i]) : direction; if (i === arr.length - 1) return !direction ? 0 : direction / Math.abs(direction); else if ((val - arr[i + 1]) * direction > 0) return 0; }};CopyisSorted([0, 1, 2, 2]); // 1isSorted([4, 3, 2]); // -1isSorted([4, 3, 5]); // 0"},{"title":"isStream","type":0,"sectionRef":"#","url":"docs/isStream","content":"Checks if the given argument is a stream.Check if the value is different from null, use typeof to check if the value is of type object and the pipe property is of type function.Copyconst isStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function';Copyconst fs = require('fs');isStream(fs.createReadStream('test.txt')); // true"},{"title":"isString","type":0,"sectionRef":"#","url":"docs/isString","content":"Checks if the given argument is a string. Only works for string primitives.Use typeof to check if a value is classified as a string primitive.Copyconst isString = val => typeof val === 'string';CopyisString('10'); // true"},{"title":"isSymbol","type":0,"sectionRef":"#","url":"docs/isSymbol","content":"Checks if the given argument is a symbol.Use typeof to check if a value is classified as a symbol primitive.Copyconst isSymbol = val => typeof val === 'symbol';CopyisSymbol(Symbol('x')); // true"},{"title":"isTravisCI","type":0,"sectionRef":"#","url":"docs/isTravisCI","content":"Checks if the current environment is Travis CI.Checks if the current environment has the TRAVIS and CI environment variables (reference).Copyconst isTravisCI = () => 'TRAVIS' in process.env && 'CI' in process.env;CopyisTravisCI(); // true (if code is running on Travis CI)"},{"title":"isUndefined","type":0,"sectionRef":"#","url":"docs/isUndefined","content":"Returns true if the specified value is undefined, false otherwise.Use the strict equality operator to check if val is equal to undefined.Copyconst isUndefined = val => val === undefined;CopyisUndefined(undefined); // true"},{"title":"isUpperCase","type":0,"sectionRef":"#","url":"docs/isUpperCase","content":"Checks if a string is upper case.Convert the given string to upper case, using String.prototype.toUpperCase() and compare it to the original.Copyconst isUpperCase = str => str === str.toUpperCase();CopyisUpperCase('ABC'); // trueisUpperCase('A3@$'); // trueisUpperCase('aB4'); // false"},{"title":"isValidJSON","type":0,"sectionRef":"#","url":"docs/isValidJSON","content":"Checks if the provided string is a valid JSON.Use JSON.parse() and a try... catch block to check if the provided string is a valid JSON.Copyconst isValidJSON = str => { try { JSON.parse(str); return true; } catch (e) { return false; }};CopyisValidJSON('{\"name\":\"Adam\",\"age\":20}'); // trueisValidJSON('{\"name\":\"Adam\",age:\"20\"}'); // falseisValidJSON(null); // true"},{"title":"isWeekday","type":0,"sectionRef":"#","url":"docs/isWeekday","content":"Results in a boolean representation of a specific date.Pass the specific date object firstly. Use Date.getDay() to check weekday by using a modulo operator and then returning a boolean.Copyconst isWeekday = (t = new Date()) => { return t.getDay() % 6 !== 0;};CopyisWeekday(); // true (if current date is 2019-07-19)"},{"title":"isWeekend","type":0,"sectionRef":"#","url":"docs/isWeekend","content":"Results in a boolean representation of a specific date.Pass the specific date object firstly. Use Date.getDay() to check weekend based on the day being returned as 0 - 6 using a modulo operation then return a boolean.Copyconst isWeekend = (t = new Date()) => { return t.getDay() % 6 === 0;};CopyisWeekend(); // 2018-10-19 (if current date is 2018-10-18)"},{"title":"isWritableStream","type":0,"sectionRef":"#","url":"docs/isWritableStream","content":"Checks if the given argument is a writable stream.Check if the value is different from null, use typeof to check if the value is of type object and the pipe property is of type function. Additionally check if the typeof the _write and _writableState properties are function and object respectively.Copyconst isWritableStream = val => val !== null && typeof val === 'object' && typeof val.pipe === 'function' && typeof val._write === 'function' && typeof val._writableState === 'object';Copyconst fs = require('fs');isWritableStream(fs.createWriteStream('test.txt')); // true"},{"title":"join","type":0,"sectionRef":"#","url":"docs/join","content":"Joins all elements of an array into a string and returns this string. Uses a separator and an end separator.Use Array.prototype.reduce() to combine elements into a string. Omit the second argument, separator, to use a default separator of ','. Omit the third argument, end, to use the same value as separator by default.Copy const join = (arr, separator = ',', end = separator) => arr.reduce( (acc, val, i) => i === arr.length - 2 ? acc + val + end : i === arr.length - 1 ? acc + val : acc + val + separator, '' );Copyjoin(['pen', 'pineapple', 'apple', 'pen'], ',', '&'); // \"pen,pineapple,apple&pen\"join(['pen', 'pineapple', 'apple', 'pen'], ','); // \"pen,pineapple,apple,pen\"join(['pen', 'pineapple', 'apple', 'pen']); // \"pen,pineapple,apple,pen\""},{"title":"juxt","type":0,"sectionRef":"#","url":"docs/juxt","content":"Takes several functions as argument and returns a function that is the juxtaposition of those functions.Use Array.prototype.map() to return a fn that can take a variable number of args. When fn is called, return an array containing the result of applying each fn to the args.Copyconst juxt = (...fns) => (...args) => [...fns].map(fn => [...args].map(fn));Copyjuxt( x => x + 1, x => x - 1, x => x * 10)(1, 2, 3); // [[2,3,4],[0,1,2],[10,20,30]] juxt( s => s.length, s => s.split(\" \").join(\"-\"))(\"30 seconds of code\"); // [[18],['30-seconds-of-code']]"},{"title":"last","type":0,"sectionRef":"#","url":"docs/last","content":"Returns the last element in an array.Check if arr is truthy and has a length property, use arr.length - 1 to compute the index of the last element of the given array and return it, otherwise return undefined.Copyconst last = arr => (arr && arr.length ? arr[arr.length - 1] : undefined);Copylast([1, 2, 3]); // 3last([]); // undefinedlast(null); // undefinedlast(undefined); // undefined"},{"title":"lcm","type":0,"sectionRef":"#","url":"docs/lcm","content":"Returns the least common multiple of two or more numbers.Use the greatest common divisor (GCD) formula and the fact that lcm(x,y) = x * y / gcd(x,y) to determine the least common multiple. The GCD formula uses recursion.Copyconst lcm = (...arr) => { const gcd = (x, y) => (!y ? x : gcd(y, x % y)); const _lcm = (x, y) => (x * y) / gcd(x, y); return [...arr].reduce((a, b) => _lcm(a, b));};Copylcm(12, 7); // 84lcm(...[1, 3, 4, 5]); // 60"},{"title":"listenOnce","type":0,"sectionRef":"#","url":"docs/listenOnce","content":"Adds an event listener to an element that will only run the callback the first time the event is triggered.Use EventTarget.addEventListener() to add an event listener to an element, storing the reference in a variable. Use a condition to call fn only the first time the listener is triggered. Copyconst listenOnce = (el, evt, fn) => { let fired = false; el.addEventListener(evt, (e) => { if (!fired) fn(e); fired = true; });};CopylistenOnce( document.getElementById('my-id), 'click', () => console.log('Hello world')); // 'Hello world' will only be logged on the first click"},{"title":"longestItem","type":0,"sectionRef":"#","url":"docs/longestItem","content":"Takes any number of iterable objects or objects with a length property and returns the longest one. If multiple objects have the same length, the first one will be returned. Returns undefined if no arguments are provided.Use Array.prototype.reduce(), comparing the length of objects to find the longest one.Copyconst longestItem = (...vals) => vals.reduce((a, x) => (x.length > a.length ? x : a));CopylongestItem('this', 'is', 'a', 'testcase'); // 'testcase'longestItem(...['a', 'ab', 'abc']); // 'abc'longestItem(...['a', 'ab', 'abc'], 'abcd'); // 'abcd'longestItem([1, 2, 3], [1, 2], [1, 2, 3, 4, 5]); // [1, 2, 3, 4, 5]longestItem([1, 2, 3], 'foobar'); // 'foobar'"},{"title":"lowercaseKeys","type":0,"sectionRef":"#","url":"docs/lowercaseKeys","content":"Creates a new object from the specified object, where all the keys are in lowercase.Use Object.keys() and Array.prototype.reduce() to create a new object from the specified object. Convert each key in the original object to lowercase, using String.toLowerCase().Copyconst lowercaseKeys = obj => Object.keys(obj).reduce((acc, key) => { acc[key.toLowerCase()] = obj[key]; return acc; }, {});Copyconst myObj = { Name: 'Adam', sUrnAME: 'Smith' };const myObjLower = lowercaseKeys(myObj); // {name: 'Adam', surname: 'Smith'};"},{"title":"luhnCheck","type":0,"sectionRef":"#","url":"docs/luhnCheck","content":"Implementation of the Luhn Algorithm used to validate a variety of identification numbers, such as credit card numbers, IMEI numbers, National Provider Identifier numbers etc.Use String.prototype.split(''), Array.prototype.reverse() and Array.prototype.map() in combination with parseInt() to obtain an array of digits. Use Array.prototype.splice(0,1) to obtain the last digit. Use Array.prototype.reduce() to implement the Luhn Algorithm. Return true if sum is divisible by 10, false otherwise.Copyconst luhnCheck = num => { let arr = (num + '') .split('') .reverse() .map(x => parseInt(x)); let lastDigit = arr.splice(0, 1)[0]; let sum = arr.reduce((acc, val, i) => (i % 2 !== 0 ? acc + val : acc + ((val * 2) % 9) || 9), 0); sum += lastDigit; return sum % 10 === 0;};CopyluhnCheck('4485275742308327'); // trueluhnCheck(6011329933655299); // falseluhnCheck(123456789); // false"},{"title":"mapKeys","type":0,"sectionRef":"#","url":"docs/mapKeys","content":"Creates an object with keys generated by running the provided function for each key and the same values as the provided object.Use Object.keys(obj) to iterate over the object's keys. Use Array.prototype.reduce() to create a new object with the same values and mapped keys using fn.Copyconst mapKeys = (obj, fn) => Object.keys(obj).reduce((acc, k) => { acc[fn(obj[k], k, obj)] = obj[k]; return acc; }, {});CopymapKeys({ a: 1, b: 2 }, (val, key) => key + val); // { a1: 1, b2: 2 }"},{"title":"mapNumRange","type":0,"sectionRef":"#","url":"docs/mapNumRange","content":"Maps a number from one range to another range.Returns num mapped between outMin-outMax from inMin-inMax.Copyconst mapNumRange = (num, inMin, inMax, outMin, outMax) => ((num - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;CopymapNumRange(5, 0, 10, 0, 100); // 50"},{"title":"mapObject","type":0,"sectionRef":"#","url":"docs/mapObject","content":"Maps the values of an array to an object using a function, where the key-value pairs consist of the original value as the key and the result of the function as the value.Use Array.prototype.reduce() to apply fn to each element in arr and combine the results into an object. Use el as the key for each property and the result of fn as the value.Copyconst mapObject = (arr, fn) => arr.reduce((acc, el, i) => { acc[el] = fn(el, i, arr); return acc; }, {});CopymapObject([1, 2, 3], a => a * a); // { 1: 1, 2: 4, 3: 9 }"},{"title":"mapString","type":0,"sectionRef":"#","url":"docs/mapString","content":"Creates a new string with the results of calling a provided function on every character in the calling string.Use String.prototype.split('') and Array.prototype.map() to call the provided function, fn, for each character in str. Use Array.prototype.join('') to recombine the array of characters into a string. The callback function, fn, takes three arguments (the current character, the index of the current character and the string mapString was called upon).Copyconst mapString = (str, fn) => str .split('') .map((c, i) => fn(c, i, str)) .join('');CopymapString('lorem ipsum', c => c.toUpperCase()); // 'LOREM IPSUM'"},{"title":"mapValues","type":0,"sectionRef":"#","url":"docs/mapValues","content":"Creates an object with the same keys as the provided object and values generated by running the provided function for each value.Use Object.keys(obj) to iterate over the object's keys. Use Array.prototype.reduce() to create a new object with the same keys and mapped values using fn.Copyconst mapValues = (obj, fn) => Object.keys(obj).reduce((acc, k) => { acc[k] = fn(obj[k], k, obj); return acc; }, {});Copyconst users = { fred: { user: 'fred', age: 40 }, pebbles: { user: 'pebbles', age: 1 }};mapValues(users, u => u.age); // { fred: 40, pebbles: 1 }"},{"title":"mask","type":0,"sectionRef":"#","url":"docs/mask","content":"Replaces all but the last num of characters with the specified mask character.Use String.prototype.slice() to grab the portion of the characters that will remain unmasked and use String.padStart() to fill the beginning of the string with the mask character up to the original length. Omit the second argument, num, to keep a default of 4 characters unmasked. If num is negative, the unmasked characters will be at the start of the string. Omit the third argument, mask, to use a default character of '*' for the mask.Copyconst mask = (cc, num = 4, mask = '*') => `${cc}`.slice(-num).padStart(`${cc}`.length, mask);Copymask(1234567890); // '******7890'mask(1234567890, 3); // '*******890'mask(1234567890, -4, '$'); // '$$$$567890'"},{"title":"matches","type":0,"sectionRef":"#","url":"docs/matches","content":"Compares two objects to determine if the first one contains equivalent property values to the second one.Use Object.keys(source) to get all the keys of the second object, then Array.prototype.every(), Object.hasOwnProperty() and strict comparison to determine if all keys exist in the first object and have the same values.Copyconst matches = (obj, source) => Object.keys(source).every(key => obj.hasOwnProperty(key) && obj[key] === source[key]);Copymatches({ age: 25, hair: 'long', beard: true }, { hair: 'long', beard: true }); // truematches({ hair: 'long', beard: true }, { age: 25, hair: 'long', beard: true }); // false"},{"title":"matchesWith","type":0,"sectionRef":"#","url":"docs/matchesWith","content":"Compares two objects to determine if the first one contains equivalent property values to the second one, based on a provided function.Use Object.keys(source) to get all the keys of the second object, then Array.prototype.every(), Object.hasOwnProperty() and the provided function to determine if all keys exist in the first object and have equivalent values. If no function is provided, the values will be compared using the equality operator.Copyconst matchesWith = (obj, source, fn) => Object.keys(source).every(key => obj.hasOwnProperty(key) && fn ? fn(obj[key], source[key], key, obj, source) : obj[key] == source[key] );Copyconst isGreeting = val => /^h(?:i|ello)$/.test(val);matchesWith( { greeting: 'hello' }, { greeting: 'hi' }, (oV, sV) => isGreeting(oV) && isGreeting(sV)); // true"},{"title":"maxBy","type":0,"sectionRef":"#","url":"docs/maxBy","content":"Returns the maximum value of an array, after mapping each element to a value using the provided function.Use Array.prototype.map() to map each element to the value returned by fn, Math.max() to get the maximum value.Copyconst maxBy = (arr, fn) => Math.max(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));CopymaxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 8maxBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 8"},{"title":"maxDate","type":0,"sectionRef":"#","url":"docs/maxDate","content":"Returns the maximum of the given dates.Use the ES6 spread syntax with Math.max to find the maximum date value, new Date() to convert it to a Date object.Copyconst maxDate = dates => new Date(Math.max(...dates));Copyconst array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9)];maxDate(array); // 2018-03-11T22:00:00.000Z"},{"title":"maxN","type":0,"sectionRef":"#","url":"docs/maxN","content":"Returns the n maximum elements from the provided array. If n is greater than or equal to the provided array's length, then return the original array (sorted in descending order).Use Array.prototype.sort() combined with the spread operator (...) to create a shallow clone of the array and sort it in descending order. Use Array.prototype.slice() to get the specified number of elements. Omit the second argument, n, to get a one-element array.Copyconst maxN = (arr, n = 1) => [...arr].sort((a, b) => b - a).slice(0, n);CopymaxN([1, 2, 3]); // [3]maxN([1, 2, 3], 2); // [3,2]"},{"title":"Powered by MDX","type":0,"sectionRef":"#","url":"docs/mdx","content":"You can write JSX and use React components within your Markdown thanks to MDX.Docusaurus green and Facebook blue are my favorite colors.I can write Markdown alongside my JSX!"},{"title":"median","type":0,"sectionRef":"#","url":"docs/median","content":"Returns the median of an array of numbers.Find the middle of the array, use Array.prototype.sort() to sort the values. Return the number at the midpoint if length is odd, otherwise the average of the two middle numbers.Copyconst median = arr => { const mid = Math.floor(arr.length / 2), nums = [...arr].sort((a, b) => a - b); return arr.length % 2 !== 0 ? nums[mid] : (nums[mid - 1] + nums[mid]) / 2;};Copymedian([5, 6, 50, 1, -5]); // 5"},{"title":"memoize","type":0,"sectionRef":"#","url":"docs/memoize","content":"Returns the memoized (cached) function.Create an empty cache by instantiating a new Map object. Return a function which takes a single argument to be supplied to the memoized function by first checking if the function's output for that specific input value is already cached, or store and return it if not. The function keyword must be used in order to allow the memoized function to have its this context changed if necessary. Allow access to the cache by setting it as a property on the returned function.Copyconst memoize = fn => { const cache = new Map(); const cached = function(val) { return cache.has(val) ? cache.get(val) : cache.set(val, fn.call(this, val)) && cache.get(val); }; cached.cache = cache; return cached;};Copy// See the `anagrams` snippet.const anagramsCached = memoize(anagrams);anagramsCached('javascript'); // takes a long timeanagramsCached('javascript'); // returns virtually instantly since it's now cachedconsole.log(anagramsCached.cache); // The cached anagrams map"},{"title":"merge","type":0,"sectionRef":"#","url":"docs/merge","content":"Creates a new object from the combination of two or more objects.Use Array.prototype.reduce() combined with Object.keys(obj) to iterate over all objects and keys. Use hasOwnProperty() and Array.prototype.concat() to append values for keys existing in multiple objects.Copyconst merge = (...objs) => [...objs].reduce( (acc, obj) => Object.keys(obj).reduce((a, k) => { acc[k] = acc.hasOwnProperty(k) ? [].concat(acc[k]).concat(obj[k]) : obj[k]; return acc; }, {}), {} );Copyconst object = { a: [{ x: 2 }, { y: 4 }], b: 1};const other = { a: { z: 3 }, b: [2, 3], c: 'foo'};merge(object, other); // { a: [ { x: 2 }, { y: 4 }, { z: 3 } ], b: [ 1, 2, 3 ], c: 'foo' }"},{"title":"midpoint","type":0,"sectionRef":"#","url":"docs/midpoint","content":"Calculates the midpoint between two pairs of (x,y) points.Destructure the array to get x1, y1, x2 and y2, calculate the midpoint for each dimension by dividing the sum of the two endpoints by 2.Copyconst midpoint = ([x1, y1], [x2, y2]) => [(x1 + x2) / 2, (y1 + y2) / 2];Copymidpoint([2, 2], [4, 4]); // [3, 3]midpoint([4, 4], [6, 6]); // [5, 5]midpoint([1, 3], [2, 4]); // [1.5, 3.5]"},{"title":"minBy","type":0,"sectionRef":"#","url":"docs/minBy","content":"Returns the minimum value of an array, after mapping each element to a value using the provided function.Use Array.prototype.map() to map each element to the value returned by fn, Math.min() to get the minimum value.Copyconst minBy = (arr, fn) => Math.min(...arr.map(typeof fn === 'function' ? fn : val => val[fn]));CopyminBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 2minBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 2"},{"title":"minDate","type":0,"sectionRef":"#","url":"docs/minDate","content":"Returns the minimum of the given dates.Use the ES6 spread syntax to find the minimum date value, new Date() to convert it to a Date object.Copyconst minDate = dates => new Date(Math.min(...dates));Copyconst array = [ new Date(2017, 4, 13), new Date(2018, 2, 12), new Date(2016, 0, 10), new Date(2016, 0, 9)];minDate(array); // 2016-01-08T22:00:00.000Z"},{"title":"minN","type":0,"sectionRef":"#","url":"docs/minN","content":"Returns the n minimum elements from the provided array. If n is greater than or equal to the provided array's length, then return the original array (sorted in ascending order).Use Array.prototype.sort() combined with the spread operator (...) to create a shallow clone of the array and sort it in ascending order. Use Array.prototype.slice() to get the specified number of elements. Omit the second argument, n, to get a one-element array.Copyconst minN = (arr, n = 1) => [...arr].sort((a, b) => a - b).slice(0, n);CopyminN([1, 2, 3]); // [1]minN([1, 2, 3], 2); // [1,2]"},{"title":"mostFrequent","type":0,"sectionRef":"#","url":"docs/mostFrequent","content":"Returns the most frequent element in an array.Use Array.prototype.reduce() to map unique values to an object's keys, adding to existing keys every time the same value is encountered. Use Object.entries() on the result in combination with Array.prototype.reduce() to get the most frequent value in the array.Copyconst mostFrequent = arr => Object.entries( arr.reduce((a, v) => { a[v] = a[v] ? a[v] + 1 : 1; return a; }, {}) ).reduce((a, v) => (v[1] >= a[1] ? v : a), [null, 0])[0];CopymostFrequent(['a', 'b', 'a', 'c', 'a', 'a', 'b']); // 'a'"},{"title":"mostPerformant","type":0,"sectionRef":"#","url":"docs/mostPerformant","content":"Returns the index of the function in an array of functions which executed the fastest.Use Array.prototype.map() to generate an array where each value is the total time taken to execute the function after iterations times. Use the difference in performance.now() values before and after to get the total time in milliseconds to a high degree of accuracy. Use Math.min() to find the minimum execution time, and return the index of that shortest time which corresponds to the index of the most performant function. Omit the second argument, iterations, to use a default of 10,000 iterations. The more iterations, the more reliable the result but the longer it will take.Copyconst mostPerformant = (fns, iterations = 10000) => { const times = fns.map(fn => { const before = performance.now(); for (let i = 0; i < iterations; i++) fn(); return performance.now() - before; }); return times.indexOf(Math.min(...times));};CopymostPerformant([ () => { // Loops through the entire array before returning `false` [1, 2, 3, 4, 5, 6, 7, 8, 9, '10'].every(el => typeof el === 'number'); }, () => { // Only needs to reach index `1` before returning false [1, '2', 3, 4, 5, 6, 7, 8, 9, 10].every(el => typeof el === 'number'); }]); // 1"},{"title":"negate","type":0,"sectionRef":"#","url":"docs/negate","content":"Negates a predicate function.Take a predicate function and apply the not operator (!) to it with its arguments.Copyconst negate = func => (...args) => !func(...args);Copy[1, 2, 3, 4, 5, 6].filter(negate(n => n % 2 === 0)); // [ 1, 3, 5 ]"},{"title":"nest","type":0,"sectionRef":"#","url":"docs/nest","content":"Given a flat array of objects linked to one another, it will nest them recursively. Useful for nesting comments, such as the ones on reddit.com.Use recursion. Use Array.prototype.filter() to filter the items where the id matches the link, then Array.prototype.map() to map each one to a new object that has a children property which recursively nests the items based on which ones are children of the current item. Omit the second argument, id, to default to null which indicates the object is not linked to another one (i.e. it is a top level object). Omit the third argument, link, to use 'parent_id' as the default property which links the object to another one by its id.Copyconst nest = (items, id = null, link = 'parent_id') => items .filter(item => item[link] === id) .map(item => ({ ...item, children: nest(items, item.id, link) }));Copy// One top level commentconst comments = [ { id: 1, parent_id: null }, { id: 2, parent_id: 1 }, { id: 3, parent_id: 1 }, { id: 4, parent_id: 2 }, { id: 5, parent_id: 4 }];const nestedComments = nest(comments); // [{ id: 1, parent_id: null, children: [...] }]"},{"title":"nodeListToArray","type":0,"sectionRef":"#","url":"docs/nodeListToArray","content":"Converts a NodeList to an array.Use spread operator inside new array to convert a NodeList to an array.Copyconst nodeListToArray = nodeList => [...nodeList];CopynodeListToArray(document.childNodes); // [ <!DOCTYPE html>, html ]"},{"title":"none","type":0,"sectionRef":"#","url":"docs/none","content":"Returns true if the provided predicate function returns false for all elements in a collection, false otherwise.Use Array.prototype.some() to test if any elements in the collection return true based on fn. Omit the second argument, fn, to use Boolean as a default.Copyconst none = (arr, fn = Boolean) => !arr.some(fn);Copynone([0, 1, 3, 0], x => x == 2); // truenone([0, 0, 0]); // true"},{"title":"normalizeLineEndings","type":0,"sectionRef":"#","url":"docs/normalizeLineEndings","content":"Normalizes line endings in a string.Use String.prototype.replace() and a regular expression to match and replace line endings with the normalized version. Omit the seconds argument, normalized, to use the default value of '\\r\\n'.Copyconst normalizeLineEndings = (str, normalized = '\\r\\n') => str.replace(/\\r?\\n/g, normalized);CopysplitLines('This\\r\\nis a\\nmultiline\\nstring.\\r\\n'); // 'This\\r\\nis a\\r\\nmultiline\\r\\nstring.\\r\\n'splitLines('This\\r\\nis a\\nmultiline\\nstring.\\r\\n', '\\n'); // 'This\\nis a\\nmultiline\\nstring.\\n'"},{"title":"not","type":0,"sectionRef":"#","url":"docs/not","content":"Returns the logical inverse of the given value.Use the logical not (!) operator to return the inverse of the given value.Copyconst not = a => !a;Copynot(true); // falsenot(false); // true"},{"title":"nthArg","type":0,"sectionRef":"#","url":"docs/nthArg","content":"Creates a function that gets the argument at index n. If n is negative, the nth argument from the end is returned.Use Array.prototype.slice() to get the desired argument at index n.Copyconst nthArg = n => (...args) => args.slice(n)[0];Copyconst third = nthArg(2);third(1, 2, 3); // 3third(1, 2); // undefinedconst last = nthArg(-1);last(1, 2, 3, 4, 5); // 5"},{"title":"nthElement","type":0,"sectionRef":"#","url":"docs/nthElement","content":"Returns the nth element of an array.Use Array.prototype.slice() to get an array containing the nth element at the first place. If the index is out of bounds, return undefined. Omit the second argument, n, to get the first element of the array.Copyconst nthElement = (arr, n = 0) => (n === -1 ? arr.slice(n) : arr.slice(n, n + 1))[0];CopynthElement(['a', 'b', 'c'], 1); // 'b'nthElement(['a', 'b', 'b'], -3); // 'a'"},{"title":"objectFromPairs","type":0,"sectionRef":"#","url":"docs/objectFromPairs","content":"Creates an object from the given key-value pairs.Use Array.prototype.reduce() to create and combine key-value pairs.Copyconst objectFromPairs = arr => arr.reduce((a, [key, val]) => ((a[key] = val), a), {});CopyobjectFromPairs([['a', 1], ['b', 2]]); // {a: 1, b: 2}"},{"title":"objectToEntries","type":0,"sectionRef":"#","url":"docs/objectToEntries","content":"Creates an array of key-value pair arrays from an object.Use Object.keys() and Array.prototype.map() to iterate over the object's keys and produce an array with key-value pairs.Copyconst objectToEntries = obj => Object.keys(obj).map(k => [k, obj[k]]);CopyobjectToEntries({ a: 1, b: 2 }); // [ ['a', 1], ['b', 2] ]"},{"title":"objectToPairs","type":0,"sectionRef":"#","url":"docs/objectToPairs","content":"Creates an array of key-value pair arrays from an object.Use Object.entries() to get an array of key-value pair arrays from the given object.Copyconst objectToPairs = obj => Object.entries(obj);CopyobjectToPairs({ a: 1, b: 2 }); // [ ['a', 1], ['b', 2] ]"},{"title":"objectToQueryString","type":0,"sectionRef":"#","url":"docs/objectToQueryString","content":"Returns a query string generated from the key-value pairs of the given object.Use Array.prototype.reduce() on Object.entries(queryParameters) to create the query string. Determine the symbol to be either ? or & based on the length of queryString and concatenate val to queryString only if it's a string. Return the queryString or an empty string when the queryParameters are falsy.Copy const objectToQueryString = queryParameters => { return queryParameters ? Object.entries(queryParameters).reduce((queryString, [key, val], index) => { const symbol = queryString.length === 0 ? '?' : '&'; queryString += typeof val === 'string' ? `${symbol}${key}=${val}` : ''; return queryString; }, '') : '';};CopyobjectToQueryString({ page: '1', size: '2kg', key: undefined }); // '?page=1&size=2kg'"},{"title":"observeMutations","type":0,"sectionRef":"#","url":"docs/observeMutations","content":"Returns a new MutationObserver and runs the provided callback for each mutation on the specified element.Use a MutationObserver to observe mutations on the given element. Use Array.prototype.forEach() to run the callback for each mutation that is observed. Omit the third argument, options, to use the default options (all true).Copyconst observeMutations = (element, callback, options) => { const observer = new MutationObserver(mutations => mutations.forEach(m => callback(m))); observer.observe( element, Object.assign( { childList: true, attributes: true, attributeOldValue: true, characterData: true, characterDataOldValue: true, subtree: true }, options ) ); return observer;};Copyconst obs = observeMutations(document, console.log); // Logs all mutations that happen on the pageobs.disconnect(); // Disconnects the observer and stops logging mutations on the page"},{"title":"off","type":0,"sectionRef":"#","url":"docs/off","content":"Removes an event listener from an element.Use EventTarget.removeEventListener() to remove an event listener from an element. Omit the fourth argument opts to use false or specify it based on the options used when the event listener was added.Copyconst off = (el, evt, fn, opts = false) => el.removeEventListener(evt, fn, opts);Copyconst fn = () => console.log('!');document.body.addEventListener('click', fn);off(document.body, 'click', fn); // no longer logs '!' upon clicking on the page"},{"title":"offset","type":0,"sectionRef":"#","url":"docs/offset","content":"Moves the specified amount of elements to the end of the array.Use Array.prototype.slice() twice to get the elements after the specified index and the elements before that. Use the spread operator(...) to combine the two into one array. If offset is negative, the elements will be moved from end to start.Copyconst offset = (arr, offset) => [...arr.slice(offset), ...arr.slice(0, offset)];Copyoffset([1, 2, 3, 4, 5], 2); // [3, 4, 5, 1, 2]offset([1, 2, 3, 4, 5], -2); // [4, 5, 1, 2, 3]"},{"title":"omit","type":0,"sectionRef":"#","url":"docs/omit","content":"Omits the key-value pairs corresponding to the given keys from an object.Use Object.keys(obj), Array.prototype.filter() and Array.prototype.includes() to remove the provided keys. Use Array.prototype.reduce() to convert the filtered keys back to an object with the corresponding key-value pairs.Copyconst omit = (obj, arr) => Object.keys(obj) .filter(k => !arr.includes(k)) .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});Copyomit({ a: 1, b: '2', c: 3 }, ['b']); // { 'a': 1, 'c': 3 }"},{"title":"omitBy","type":0,"sectionRef":"#","url":"docs/omitBy","content":"Creates an object composed of the properties the given function returns falsy for. The function is invoked with two arguments: (value, key).Use Object.keys(obj) and Array.prototype.filter()to remove the keys for which fn returns a truthy value. Use Array.prototype.reduce() to convert the filtered keys back to an object with the corresponding key-value pairs.Copyconst omitBy = (obj, fn) => Object.keys(obj) .filter(k => !fn(obj[k], k)) .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});CopyomitBy({ a: 1, b: '2', c: 3 }, x => typeof x === 'number'); // { b: '2' }"},{"title":"on","type":0,"sectionRef":"#","url":"docs/on","content":"Adds an event listener to an element with the ability to use event delegation.Use EventTarget.addEventListener() to add an event listener to an element. If there is a target property supplied to the options object, ensure the event target matches the target specified and then invoke the callback by supplying the correct this context. Returns a reference to the custom delegator function, in order to be possible to use with off. Omit opts to default to non-delegation behavior and event bubbling.Copyconst on = (el, evt, fn, opts = {}) => { const delegatorFn = e => e.target.matches(opts.target) && fn.call(e.target, e); el.addEventListener(evt, opts.target ? delegatorFn : fn, opts.options || false); if (opts.target) return delegatorFn;};Copyconst fn = () => console.log('!');on(document.body, 'click', fn); // logs '!' upon clicking the bodyon(document.body, 'click', fn, { target: 'p' }); // logs '!' upon clicking a `p` element child of the bodyon(document.body, 'click', fn, { options: true }); // use capturing instead of bubbling"},{"title":"onUserInputChange","type":0,"sectionRef":"#","url":"docs/onUserInputChange","content":"Run the callback whenever the user input type changes (mouse or touch). Useful for enabling/disabling code depending on the input device. This process is dynamic and works with hybrid devices (e.g. touchscreen laptops).Use two event listeners. Assume mouse input initially and bind a touchstart event listener to the document. On touchstart, add a mousemove event listener to listen for two consecutive mousemove events firing within 20ms, using performance.now(). Run the callback with the input type as an argument in either of these situations.Copyconst onUserInputChange = callback => { let type = 'mouse', lastTime = 0; const mousemoveHandler = () => { const now = performance.now(); if (now - lastTime < 20) (type = 'mouse'), callback(type), document.removeEventListener('mousemove', mousemoveHandler); lastTime = now; }; document.addEventListener('touchstart', () => { if (type === 'touch') return; (type = 'touch'), callback(type), document.addEventListener('mousemove', mousemoveHandler); });};CopyonUserInputChange(type => { console.log('The user is now using', type, 'as an input method.');});"},{"title":"once","type":0,"sectionRef":"#","url":"docs/once","content":"Ensures a function is called only once.Utilizing a closure, use a flag, called, and set it to true once the function is called for the first time, preventing it from being called again. In order to allow the function to have its this context changed (such as in an event listener), the function keyword must be used, and the supplied function must have the context applied. Allow the function to be supplied with an arbitrary number of arguments using the rest/spread (...) operator.Copyconst once = fn => { let called = false; return function(...args) { if (called) return; called = true; return fn.apply(this, args); };};Copyconst startApp = function(event) { console.log(this, event); // document.body, MouseEvent};document.body.addEventListener('click', once(startApp)); // only runs `startApp` once upon click"},{"title":"or","type":0,"sectionRef":"#","url":"docs/or","content":"Returns true if at least one of the arguments is true, false otherwise.Use the logical or (||) operator on the two given values.Copyconst or = (a, b) => a || b;Copyor(true, true); // trueor(true, false); // trueor(false, false); // false"},{"title":"orderBy","type":0,"sectionRef":"#","url":"docs/orderBy","content":"Returns a sorted array of objects ordered by properties and orders.Uses Array.prototype.sort(), Array.prototype.reduce() on the props array with a default value of 0, use array destructuring to swap the properties position depending on the order passed. If no orders array is passed it sort by 'asc' by default.Copyconst orderBy = (arr, props, orders) => [...arr].sort((a, b) => props.reduce((acc, prop, i) => { if (acc === 0) { const [p1, p2] = orders && orders[i] === 'desc' ? [b[prop], a[prop]] : [a[prop], b[prop]]; acc = p1 > p2 ? 1 : p1 < p2 ? -1 : 0; } return acc; }, 0) );Copyconst users = [{ name: 'fred', age: 48 }, { name: 'barney', age: 36 }, { name: 'fred', age: 40 }];orderBy(users, ['name', 'age'], ['asc', 'desc']); // [{name: 'barney', age: 36}, {name: 'fred', age: 48}, {name: 'fred', age: 40}]orderBy(users, ['name', 'age']); // [{name: 'barney', age: 36}, {name: 'fred', age: 40}, {name: 'fred', age: 48}]"},{"title":"over","type":0,"sectionRef":"#","url":"docs/over","content":"Creates a function that invokes each provided function with the arguments it receives and returns the results.Use Array.prototype.map() and Function.prototype.apply() to apply each function to the given arguments.Copyconst over = (...fns) => (...args) => fns.map(fn => fn.apply(null, args));Copyconst minMax = over(Math.min, Math.max);minMax(1, 2, 3, 4, 5); // [1,5]"},{"title":"overArgs","type":0,"sectionRef":"#","url":"docs/overArgs","content":"Creates a function that invokes the provided function with its arguments transformed.Use Array.prototype.map() to apply transforms to args in combination with the spread operator (...) to pass the transformed arguments to fn.Copyconst overArgs = (fn, transforms) => (...args) => fn(...args.map((val, i) => transforms[i](val)));Copyconst square = n => n * n;const double = n => n * 2;const fn = overArgs((x, y) => [x, y], [square, double]);fn(9, 3); // [81, 6]"},{"title":"pad","type":0,"sectionRef":"#","url":"docs/pad","content":"Pads a string on both sides with the specified character, if it's shorter than the specified length.Use String.prototype.padStart() and String.prototype.padEnd() to pad both sides of the given string. Omit the third argument, char, to use the whitespace character as the default padding character.Copyconst pad = (str, length, char = ' ') => str.padStart((str.length + length) / 2, char).padEnd(length, char);Copypad('cat', 8); // ' cat 'pad(String(42), 6, '0'); // '004200'pad('foobar', 3); // 'foobar'"},{"title":"palindrome","type":0,"sectionRef":"#","url":"docs/palindrome","content":"Returns true if the given string is a palindrome, false otherwise.Convert the string to String.prototype.toLowerCase() and use String.prototype.replace() to remove non-alphanumeric characters from it. Then, use the spread operator (...) to split the string into individual characters, Array.prototype.reverse(), String.prototype.join('') and compare it to the original, unreversed string, after converting it to String.prototype.toLowerCase().Copyconst palindrome = str => { const s = str.toLowerCase().replace(/[\\W_]/g, ''); return s === [...s].reverse().join('');};Copypalindrome('taco cat'); // true"},{"title":"parseCookie","type":0,"sectionRef":"#","url":"docs/parseCookie","content":"Parse an HTTP Cookie header string and return an object of all cookie name-value pairs.Use String.prototype.split(';') to separate key-value pairs from each other. Use Array.prototype.map() and String.prototype.split('=') to separate keys from values in each pair. Use Array.prototype.reduce() and decodeURIComponent() to create an object with all key-value pairs.Copyconst parseCookie = str => str .split(';') .map(v => v.split('=')) .reduce((acc, v) => { acc[decodeURIComponent(v[0].trim())] = decodeURIComponent(v[1].trim()); return acc; }, {});CopyparseCookie('foo=bar; equation=E%3Dmc%5E2'); // { foo: 'bar', equation: 'E=mc^2' }"},{"title":"partial","type":0,"sectionRef":"#","url":"docs/partial","content":"Creates a function that invokes fn with partials prepended to the arguments it receives.Use the spread operator (...) to prepend partials to the list of arguments of fn.Copyconst partial = (fn, ...partials) => (...args) => fn(...partials, ...args);Copyconst greet = (greeting, name) => greeting + ' ' + name + '!';const greetHello = partial(greet, 'Hello');greetHello('John'); // 'Hello John!'"},{"title":"partialRight","type":0,"sectionRef":"#","url":"docs/partialRight","content":"Creates a function that invokes fn with partials appended to the arguments it receives.Use the spread operator (...) to append partials to the list of arguments of fn.Copyconst partialRight = (fn, ...partials) => (...args) => fn(...args, ...partials);Copyconst greet = (greeting, name) => greeting + ' ' + name + '!';const greetJohn = partialRight(greet, 'John');greetJohn('Hello'); // 'Hello John!'"},{"title":"partition","type":0,"sectionRef":"#","url":"docs/partition","content":"Groups the elements into two arrays, depending on the provided function's truthiness for each element.Use Array.prototype.reduce() to create an array of two arrays. Use Array.prototype.push() to add elements for which fn returns true to the first array and elements for which fn returns false to the second one.Copyconst partition = (arr, fn) => arr.reduce( (acc, val, i, arr) => { acc[fn(val, i, arr) ? 0 : 1].push(val); return acc; }, [[], []] );Copyconst users = [{ user: 'barney', age: 36, active: false }, { user: 'fred', age: 40, active: true }];partition(users, o => o.active); // [[{ 'user': 'fred', 'age': 40, 'active': true }],[{ 'user': 'barney', 'age': 36, 'active': false }]]"},{"title":"partitionBy","type":0,"sectionRef":"#","url":"docs/partitionBy","content":"Applies fn to each value in arr, splitting it each time fn returns a new value.Use Array.prototype.reduce() with an accumulator object that will hold the resulting array and the last value returned from fn. Use Array.prototype.push() to add each value in arr to the appropriate partition in the accumulator array.Copyconst partitionBy = (arr, fn) => arr.reduce( ({ res, last }, v, i, a) => { const next = fn(v, i, a); if (next !== last) res.push([v]); else res[res.length - 1].push(v); return { res, last: next }; }, { res: [] } ).res;Copyconst numbers = [1, 1, 3, 3, 4, 5, 5, 5];partitionBy(numbers, n => n % 2 === 0); // [[1, 1, 3, 3], [4], [5, 5, 5]]partitionBy(numbers, n => n); // [[1, 1], [3, 3], [4], [5, 5, 5]]"},{"title":"percentile","type":0,"sectionRef":"#","url":"docs/percentile","content":"Uses the percentile formula to calculate how many numbers in the given array are less or equal to the given value.Use Array.prototype.reduce() to calculate how many numbers are below the value and how many are the same value and apply the percentile formula.Copyconst percentile = (arr, val) => (100 * arr.reduce((acc, v) => acc + (v < val ? 1 : 0) + (v === val ? 0.5 : 0), 0)) / arr.length;Copypercentile([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 6); // 55"},{"title":"permutations","type":0,"sectionRef":"#","url":"docs/permutations","content":"Generates all permutations of an array's elements (contains duplicates).⚠️ WARNING: This function's execution time increases exponentially with each array element. Anything more than 8 to 10 entries will cause your browser to hang as it tries to solve all the different combinations.Use recursion. For each element in the given array, create all the partial permutations for the rest of its elements. Use Array.prototype.map() to combine the element with each partial permutation, then Array.prototype.reduce() to combine all permutations in one array. Base cases are for array length equal to 2 or 1.Copyconst permutations = arr => { if (arr.length <= 2) return arr.length === 2 ? [arr, [arr[1], arr[0]]] : arr; return arr.reduce( (acc, item, i) => acc.concat( permutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(val => [item, ...val]) ), [] );};Copypermutations([1, 33, 5]); // [ [ 1, 33, 5 ], [ 1, 5, 33 ], [ 33, 1, 5 ], [ 33, 5, 1 ], [ 5, 1, 33 ], [ 5, 33, 1 ] ]"},{"title":"pick","type":0,"sectionRef":"#","url":"docs/pick","content":"Picks the key-value pairs corresponding to the given keys from an object.Use Array.prototype.reduce() to convert the filtered/picked keys back to an object with the corresponding key-value pairs if the key exists in the object.Copyconst pick = (obj, arr) => arr.reduce((acc, curr) => (curr in obj && (acc[curr] = obj[curr]), acc), {});Copypick({ a: 1, b: '2', c: 3 }, ['a', 'c']); // { 'a': 1, 'c': 3 }"},{"title":"pickBy","type":0,"sectionRef":"#","url":"docs/pickBy","content":"Creates an object composed of the properties the given function returns truthy for. The function is invoked with two arguments: (value, key).Use Object.keys(obj) and Array.prototype.filter()to remove the keys for which fn returns a falsy value. Use Array.prototype.reduce() to convert the filtered keys back to an object with the corresponding key-value pairs.Copyconst pickBy = (obj, fn) => Object.keys(obj) .filter(k => fn(obj[k], k)) .reduce((acc, key) => ((acc[key] = obj[key]), acc), {});CopypickBy({ a: 1, b: '2', c: 3 }, x => typeof x === 'number'); // { 'a': 1, 'c': 3 }"},{"title":"pipeAsyncFunctions","type":0,"sectionRef":"#","url":"docs/pipeAsyncFunctions","content":"Performs left-to-right function composition for asynchronous functions.Use Array.prototype.reduce() and the spread operator (...) to perform function composition using Promise.then(). The functions can return a combination of normal values, Promises or be async, returning through await. All functions must accept a single argument.Copyconst pipeAsyncFunctions = (...fns) => arg => fns.reduce((p, f) => p.then(f), Promise.resolve(arg));Copy const sum = pipeAsyncFunctions( x => x + 1, x => new Promise(resolve => setTimeout(() => resolve(x + 2), 1000)), x => x + 3, async x => (await x) + 4);(async() => { console.log(await sum(5)); // 15 (after one second)})();"},{"title":"pipeFunctions","type":0,"sectionRef":"#","url":"docs/pipeFunctions","content":"Performs left-to-right function composition.Use Array.prototype.reduce() with the spread operator (...) to perform left-to-right function composition. The first (leftmost) function can accept one or more arguments; the remaining functions must be unary.Copyconst pipeFunctions = (...fns) => fns.reduce((f, g) => (...args) => g(f(...args)));Copyconst add5 = x => x + 5;const multiply = (x, y) => x * y;const multiplyAndAdd5 = pipeFunctions(multiply, add5);multiplyAndAdd5(5, 2); // 15"},{"title":"pluralize","type":0,"sectionRef":"#","url":"docs/pluralize","content":"Returns the singular or plural form of the word based on the input number. If the first argument is an object, it will use a closure by returning a function that can auto-pluralize words that don't simply end in s if the supplied dictionary contains the word.If num is either -1 or 1, return the singular form of the word. If num is any other number, return the plural form. Omit the third argument to use the default of the singular word + s, or supply a custom pluralized word when necessary. If the first argument is an object, utilize a closure by returning a function which can use the supplied dictionary to resolve the correct plural form of the word.Copyconst pluralize = (val, word, plural = word + 's') => { const _pluralize = (num, word, plural = word + 's') => [1, -1].includes(Number(num)) ? word : plural; if (typeof val === 'object') return (num, word) => _pluralize(num, word, val[word]); return _pluralize(val, word, plural);};Copypluralize(0, 'apple'); // 'apples'pluralize(1, 'apple'); // 'apple'pluralize(2, 'apple'); // 'apples'pluralize(2, 'person', 'people'); // 'people' const PLURALS = { person: 'people', radius: 'radii'};const autoPluralize = pluralize(PLURALS);autoPluralize(2, 'person'); // 'people'"},{"title":"powerset","type":0,"sectionRef":"#","url":"docs/powerset","content":"Returns the powerset of a given array of numbers.Use Array.prototype.reduce() combined with Array.prototype.map() to iterate over elements and combine into an array containing all combinations.Copyconst powerset = arr => arr.reduce((a, v) => a.concat(a.map(r => [v].concat(r))), [[]]);Copypowerset([1, 2]); // [[], [1], [2], [2, 1]]"},{"title":"prefersDarkColorScheme","type":0,"sectionRef":"#","url":"docs/prefersDarkColorScheme","content":"Returns true if the user color scheme preference is dark, false otherwise.Use window.matchMedia() with the appropriate media query to check the user color scheme preference.Copyconst prefersDarkColorScheme = () => window && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;CopyprefersDarkColorScheme(); // true"},{"title":"prefersLightColorScheme","type":0,"sectionRef":"#","url":"docs/prefersLightColorScheme","content":"Returns true if the user color scheme preference is light, false otherwise.Use window.matchMedia() with the appropriate media query to check the user color scheme preference.Copyconst prefersLightColorScheme = () => window && window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches;CopyprefersLightColorScheme(); // true"},{"title":"prefix","type":0,"sectionRef":"#","url":"docs/prefix","content":"Returns the prefixed version (if necessary) of a CSS property that the browser supports.Use Array.prototype.findIndex() on an array of vendor prefix strings to test if document.body has one of them defined in its CSSStyleDeclaration object, otherwise return null. Use String.prototype.charAt() and String.prototype.toUpperCase() to capitalize the property, which will be appended to the vendor prefix string.Copyconst prefix = prop => { const capitalizedProp = prop.charAt(0).toUpperCase() + prop.slice(1); const prefixes = ['', 'webkit', 'moz', 'ms', 'o']; const i = prefixes.findIndex( prefix => typeof document.body.style[prefix ? prefix + capitalizedProp : prop] !== 'undefined' ); return i !== -1 ? (i === 0 ? prop : prefixes[i] + capitalizedProp) : null;};Copyprefix('appearance'); // 'appearance' on a supported browser, otherwise 'webkitAppearance', 'mozAppearance', 'msAppearance' or 'oAppearance'"},{"title":"prettyBytes","type":0,"sectionRef":"#","url":"docs/prettyBytes","content":"Converts a number in bytes to a human-readable string.Use an array dictionary of units to be accessed based on the exponent. Use Number.toPrecision() to truncate the number to a certain number of digits. Return the prettified string by building it up, taking into account the supplied options and whether it is negative or not. Omit the second argument, precision, to use a default precision of 3 digits. Omit the third argument, addSpace, to add space between the number and unit by default.Copyconst prettyBytes = (num, precision = 3, addSpace = true) => { const UNITS = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']; if (Math.abs(num) < 1) return num + (addSpace ? ' ' : '') + UNITS[0]; const exponent = Math.min(Math.floor(Math.log10(num < 0 ? -num : num) / 3), UNITS.length - 1); const n = Number(((num < 0 ? -num : num) / 1000 ** exponent).toPrecision(precision)); return (num < 0 ? '-' : '') + n + (addSpace ? ' ' : '') + UNITS[exponent];};CopyprettyBytes(1000); // \"1 KB\"prettyBytes(-27145424323.5821, 5); // \"-27.145 GB\"prettyBytes(123456789, 3, false); // \"123MB\""},{"title":"primes","type":0,"sectionRef":"#","url":"docs/primes","content":"Generates primes up to a given number, using the Sieve of Eratosthenes.Generate an array from 2 to the given number. Use Array.prototype.filter() to filter out the values divisible by any number from 2 to the square root of the provided number.Copyconst primes = num => { let arr = Array.from({ length: num - 1 }).map((x, i) => i + 2), sqroot = Math.floor(Math.sqrt(num)), numsTillSqroot = Array.from({ length: sqroot - 1 }).map((x, i) => i + 2); numsTillSqroot.forEach(x => (arr = arr.filter(y => y % x !== 0 || y === x))); return arr;};Copyprimes(10); // [2,3,5,7]"},{"title":"promisify","type":0,"sectionRef":"#","url":"docs/promisify","content":"Converts an asynchronous function to return a promise.In Node 8+, you can use util.promisifyUse currying to return a function returning a Promise that calls the original function. Use the ...rest operator to pass in all the parameters.Copyconst promisify = func => (...args) => new Promise((resolve, reject) => func(...args, (err, result) => (err ? reject(err) : resolve(result))) );Copyconst delay = promisify((d, cb) => setTimeout(cb, d));delay(2000).then(() => console.log('Hi!')); // // Promise resolves after 2s"},{"title":"pull","type":0,"sectionRef":"#","url":"docs/pull","content":"Mutates the original array to filter out the values specified.Use Array.prototype.filter() and Array.prototype.includes() to pull out the values that are not needed. Use Array.prototype.length = 0 to mutate the passed in an array by resetting it's length to zero and Array.prototype.push() to re-populate it with only the pulled values.Copyconst pull = (arr, ...args) => { let argState = Array.isArray(args[0]) ? args[0] : args; let pulled = arr.filter(v => !argState.includes(v)); arr.length = 0; pulled.forEach(v => arr.push(v));};Copylet myArray = ['a', 'b', 'c', 'a', 'b', 'c'];pull(myArray, 'a', 'c'); // myArray = [ 'b', 'b' ]"},{"title":"pullAtIndex","type":0,"sectionRef":"#","url":"docs/pullAtIndex","content":"Mutates the original array to filter out the values at the specified indexes.Use Array.prototype.filter() and Array.prototype.includes() to pull out the values that are not needed. Use Array.prototype.length = 0 to mutate the passed in an array by resetting it's length to zero and Array.prototype.push() to re-populate it with only the pulled values. Use Array.prototype.push() to keep track of pulled valuesCopyconst pullAtIndex = (arr, pullArr) => { let removed = []; let pulled = arr .map((v, i) => (pullArr.includes(i) ? removed.push(v) : v)) .filter((v, i) => !pullArr.includes(i)); arr.length = 0; pulled.forEach(v => arr.push(v)); return removed;};Copylet myArray = ['a', 'b', 'c', 'd'];let pulled = pullAtIndex(myArray, [1, 3]); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]"},{"title":"pullAtValue","type":0,"sectionRef":"#","url":"docs/pullAtValue","content":"Mutates the original array to filter out the values specified. Returns the removed elements.Use Array.prototype.filter() and Array.prototype.includes() to pull out the values that are not needed. Use Array.prototype.length = 0 to mutate the passed in an array by resetting it's length to zero and Array.prototype.push() to re-populate it with only the pulled values. Use Array.prototype.push() to keep track of pulled valuesCopyconst pullAtValue = (arr, pullArr) => { let removed = [], pushToRemove = arr.forEach((v, i) => (pullArr.includes(v) ? removed.push(v) : v)), mutateTo = arr.filter((v, i) => !pullArr.includes(v)); arr.length = 0; mutateTo.forEach(v => arr.push(v)); return removed;};Copylet myArray = ['a', 'b', 'c', 'd'];let pulled = pullAtValue(myArray, ['b', 'd']); // myArray = [ 'a', 'c' ] , pulled = [ 'b', 'd' ]"},{"title":"pullBy","type":0,"sectionRef":"#","url":"docs/pullBy","content":"Mutates the original array to filter out the values specified, based on a given iterator function.Check if the last argument provided in a function. Use Array.prototype.map() to apply the iterator function fn to all array elements. Use Array.prototype.filter() and Array.prototype.includes() to pull out the values that are not needed. Use Array.prototype.length = 0 to mutate the passed in an array by resetting it's length to zero and Array.prototype.push() to re-populate it with only the pulled values.Copyconst pullBy = (arr, ...args) => { const length = args.length; let fn = length > 1 ? args[length - 1] : undefined; fn = typeof fn == 'function' ? (args.pop(), fn) : undefined; let argState = (Array.isArray(args[0]) ? args[0] : args).map(val => fn(val)); let pulled = arr.filter((v, i) => !argState.includes(fn(v))); arr.length = 0; pulled.forEach(v => arr.push(v));};Copyvar myArray = [{ x: 1 }, { x: 2 }, { x: 3 }, { x: 1 }];pullBy(myArray, [{ x: 1 }, { x: 3 }], o => o.x); // myArray = [{ x: 2 }]"},{"title":"radsToDegrees","type":0,"sectionRef":"#","url":"docs/radsToDegrees","content":"Converts an angle from radians to degrees.Use Math.PI and the radian to degree formula to convert the angle from radians to degrees.Copyconst radsToDegrees = rad => (rad * 180.0) / Math.PI;CopyradsToDegrees(Math.PI / 2); // 90"},{"title":"randomHexColorCode","type":0,"sectionRef":"#","url":"docs/randomHexColorCode","content":"Generates a random hexadecimal color code.Use Math.random to generate a random 24-bit(6x4bits) hexadecimal number. Use bit shifting and then convert it to an hexadecimal String using toString(16).Copyconst randomHexColorCode = () => { let n = (Math.random() * 0xfffff * 1000000).toString(16); return '#' + n.slice(0, 6);};CopyrandomHexColorCode(); // \"#e34155\""},{"title":"randomIntArrayInRange","type":0,"sectionRef":"#","url":"docs/randomIntArrayInRange","content":"Returns an array of n random integers in the specified range.Use Array.from() to create an empty array of the specific length, Math.random() to generate a random number and map it to the desired range, using Math.floor() to make it an integer.Copyconst randomIntArrayInRange = (min, max, n = 1) => Array.from({ length: n }, () => Math.floor(Math.random() * (max - min + 1)) + min);CopyrandomIntArrayInRange(12, 35, 10); // [ 34, 14, 27, 17, 30, 27, 20, 26, 21, 14 ]"},{"title":"randomIntegerInRange","type":0,"sectionRef":"#","url":"docs/randomIntegerInRange","content":"Returns a random integer in the specified range.Use Math.random() to generate a random number and map it to the desired range, using Math.floor() to make it an integer.Copyconst randomIntegerInRange = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;CopyrandomIntegerInRange(0, 5); // 2"},{"title":"randomNumberInRange","type":0,"sectionRef":"#","url":"docs/randomNumberInRange","content":"Returns a random number in the specified range.Use Math.random() to generate a random value, map it to the desired range using multiplication.Copyconst randomNumberInRange = (min, max) => Math.random() * (max - min) + min;CopyrandomNumberInRange(2, 10); // 6.0211363285087005"},{"title":"readFileLines","type":0,"sectionRef":"#","url":"docs/readFileLines","content":"Returns an array of lines from the specified file.Use readFileSync function in fs node package to create a Buffer from a file. convert buffer to string using toString(encoding) function. creating an array from contents of file by spliting file content line by line (each \\n).Copyconst fs = require('fs');const readFileLines = filename => fs .readFileSync(filename) .toString('UTF8') .split('\\n');Copy/*contents of test.txt : line1 line2 line3 ___________________________*/let arr = readFileLines('test.txt');console.log(arr); // ['line1', 'line2', 'line3']"},{"title":"rearg","type":0,"sectionRef":"#","url":"docs/rearg","content":"Creates a function that invokes the provided function with its arguments arranged according to the specified indexes.Use Array.prototype.map() to reorder arguments based on indexes in combination with the spread operator (...) to pass the transformed arguments to fn.Copyconst rearg = (fn, indexes) => (...args) => fn(...indexes.map(i => args[i]));Copyvar rearged = rearg( function(a, b, c) { return [a, b, c]; }, [2, 0, 1]);rearged('b', 'c', 'a'); // ['a', 'b', 'c']"},{"title":"recordAnimationFrames","type":0,"sectionRef":"#","url":"docs/recordAnimationFrames","content":"Invokes the provided callback on each animation frame.Use recursion. Provided that running is true, continue invoking window.requestAnimationFrame() which invokes the provided callback. Return an object with two methods start and stop to allow manual control of the recording. Omit the second argument, autoStart, to implicitly call start when the function is invoked.Copyconst recordAnimationFrames = (callback, autoStart = true) => { let running = true, raf; const stop = () => { running = false; cancelAnimationFrame(raf); }; const start = () => { running = true; run(); }; const run = () => { raf = requestAnimationFrame(() => { callback(); if (running) run(); }); }; if (autoStart) start(); return { start, stop };};Copyconst cb = () => console.log('Animation frame fired');const recorder = recordAnimationFrames(cb); // logs 'Animation frame fired' on each animation framerecorder.stop(); // stops loggingrecorder.start(); // starts againconst recorder2 = recordAnimationFrames(cb, false); // `start` needs to be explicitly called to begin recording frames"},{"title":"redirect","type":0,"sectionRef":"#","url":"docs/redirect","content":"Redirects to a specified URL.Use window.location.href or window.location.replace() to redirect to url. Pass a second argument to simulate a link click (true - default) or an HTTP redirect (false).Copyconst redirect = (url, asLink = true) => asLink ? (window.location.href = url) : window.location.replace(url);Copyredirect('https://google.com');"},{"title":"reduceSuccessive","type":0,"sectionRef":"#","url":"docs/reduceSuccessive","content":"Applies a function against an accumulator and each element in the array (from left to right), returning an array of successively reduced values.Use Array.prototype.reduce() to apply the given function to the given array, storing each new result.Copyconst reduceSuccessive = (arr, fn, acc) => arr.reduce((res, val, i, arr) => (res.push(fn(res.slice(-1)[0], val, i, arr)), res), [acc]);CopyreduceSuccessive([1, 2, 3, 4, 5, 6], (acc, val) => acc + val, 0); // [0, 1, 3, 6, 10, 15, 21]"},{"title":"reduceWhich","type":0,"sectionRef":"#","url":"docs/reduceWhich","content":"Returns the minimum/maximum value of an array, after applying the provided function to set comparing rule.Use Array.prototype.reduce() in combination with the comparator function to get the appropriate element in the array. You can omit the second parameter, comparator, to use the default one that returns the minimum element in the array.Copyconst reduceWhich = (arr, comparator = (a, b) => a - b) => arr.reduce((a, b) => (comparator(a, b) >= 0 ? b : a));CopyreduceWhich([1, 3, 2]); // 1reduceWhich([1, 3, 2], (a, b) => b - a); // 3reduceWhich( [{ name: 'Tom', age: 12 }, { name: 'Jack', age: 18 }, { name: 'Lucy', age: 9 }], (a, b) => a.age - b.age); // {name: \"Lucy\", age: 9}"},{"title":"reducedFilter","type":0,"sectionRef":"#","url":"docs/reducedFilter","content":"Filter an array of objects based on a condition while also filtering out unspecified keys.Use Array.prototype.filter() to filter the array based on the predicate fn so that it returns the objects for which the condition returned a truthy value. On the filtered array, use Array.prototype.map() to return the new object using Array.prototype.reduce() to filter out the keys which were not supplied as the keys argument.Copyconst reducedFilter = (data, keys, fn) => data.filter(fn).map(el => keys.reduce((acc, key) => { acc[key] = el[key]; return acc; }, {}) );Copyconst data = [ { id: 1, name: 'john', age: 24 }, { id: 2, name: 'mike', age: 50 }]; reducedFilter(data, ['id', 'name'], item => item.age > 24); // [{ id: 2, name: 'mike'}]"},{"title":"reject","type":0,"sectionRef":"#","url":"docs/reject","content":"Filters an array's values based on a predicate function, returning only values for which the predicate function returns false.Use Array.prototype.filter() in combination with the predicate function, pred, to return only the values for which pred() returns false.Copyconst reject = (pred, array) => array.filter((...args) => !pred(...args));Copyreject(x => x % 2 === 0, [1, 2, 3, 4, 5]); // [1, 3, 5]reject(word => word.length > 4, ['Apple', 'Pear', 'Kiwi', 'Banana']); // ['Pear', 'Kiwi']"},{"title":"remove","type":0,"sectionRef":"#","url":"docs/remove","content":"Mutates an array by removing elements for which the given function returns false.Use Array.prototype.filter() to find array elements that return truthy values and Array.prototype.reduce() to remove elements using Array.prototype.splice(). The func is invoked with three arguments (value, index, array).Copy const remove = (arr, func) => Array.isArray(arr) ? arr.filter(func).reduce((acc, val) => { arr.splice(arr.indexOf(val), 1); return acc.concat(val); }, []) : [];Copyremove([1, 2, 3, 4], n => n % 2 === 0); // [2, 4]"},{"title":"removeNonASCII","type":0,"sectionRef":"#","url":"docs/removeNonASCII","content":"Removes non-printable ASCII characters.Use a regular expression to remove non-printable ASCII characters.Copyconst removeNonASCII = str => str.replace(/[^\\x20-\\x7E]/g, '');CopyremoveNonASCII('äÄçÇéÉêlorem-ipsumöÖÐþúÚ'); // 'lorem-ipsum'"},{"title":"renameKeys","type":0,"sectionRef":"#","url":"docs/renameKeys","content":"Replaces the names of multiple object keys with the values provided.Use Object.keys() in combination with Array.prototype.reduce() and the spread operator (...) to get the object's keys and rename them according to keysMap.Copyconst renameKeys = (keysMap, obj) => Object.keys(obj).reduce( (acc, key) => ({ ...acc, ...{ [keysMap[key] || key]: obj[key] } }), {} );Copyconst obj = { name: 'Bobo', job: 'Front-End Master', shoeSize: 100 };renameKeys({ name: 'firstName', job: 'passion' }, obj); // { firstName: 'Bobo', passion: 'Front-End Master', shoeSize: 100 }"},{"title":"renderElement","type":0,"sectionRef":"#","url":"docs/renderElement","content":"Renders the given DOM tree in the specified DOM element.Destructure the first argument into type and props, use type to determine if the given element is a text element. Based on the element's type, use either Document.createTextNode() or Document.createElement() to create the DOM element. Use Object.keys(props, adding attributes to the DOM element and setting event listeners, as necessary. Use recursion to render props.children, if any. Finally, use Node.appendChild() to append the DOM element to the specified container.Copyconst renderElement = ({ type, props = {} }, container) => { const isTextElement = !type; const element = isTextElement ? document.createTextNode('') : document.createElement(type); const isListener = p => p.startsWith('on'); const isAttribute = p => !isListener(p) && p !== 'children'; Object.keys(props).forEach(p => { if(isAttribute(p)) element[p] = props[p]; if(!isTextElement && isListener(p)) element.addEventListener(p.toLowerCase().slice(2), props[p]); }); if(!isTextElement && props.children && props.children.length) props.children.forEach(childElement => renderElement(childElement, element)); container.appendChild(element);}Copyconst myElement = { type: 'button', props: { type: 'button', className: 'btn', onClick: () => alert('Clicked'), children: [ { props: { nodeValue: 'Click me' } } ] }}; renderElement( myElement, document.body);"},{"title":"reverseString","type":0,"sectionRef":"#","url":"docs/reverseString","content":"Reverses a string.Use the spread operator (...) and Array.prototype.reverse() to reverse the order of the characters in the string. Combine characters to get a string using String.prototype.join('').Copyconst reverseString = str => [...str].reverse().join('');CopyreverseString('foobar'); // 'raboof'"},{"title":"round","type":0,"sectionRef":"#","url":"docs/round","content":"Rounds a number to a specified amount of digits.Use Math.round() and template literals to round the number to the specified number of digits. Omit the second argument, decimals to round to an integer.Copyconst round = (n, decimals = 0) => Number(`${Math.round(`${n}e${decimals}`)}e-${decimals}`);Copyround(1.005, 2); // 1.01"},{"title":"runAsync","type":0,"sectionRef":"#","url":"docs/runAsync","content":"Runs a function in a separate thread by using a Web Worker, allowing long running functions to not block the UI.Create a new Worker using a Blob object URL, the contents of which should be the stringified version of the supplied function. Immediately post the return value of calling the function back. Return a promise, listening for onmessage and onerror events and resolving the data posted back from the worker, or throwing an error.Copyconst runAsync = fn => { const worker = new Worker( URL.createObjectURL(new Blob([`postMessage((${fn})());`]), { type: 'application/javascript; charset=utf-8' }) ); return new Promise((res, rej) => { worker.onmessage = ({ data }) => { res(data), worker.terminate(); }; worker.onerror = err => { rej(err), worker.terminate(); }; });};Copyconst longRunningFunction = () => { let result = 0; for (let i = 0; i < 1000; i++) for (let j = 0; j < 700; j++) for (let k = 0; k < 300; k++) result = result + i + j + k; return result;};/* NOTE: Since the function is running in a different context, closures are not supported. The function supplied to `runAsync` gets stringified, so everything becomes literal. All variables and functions must be defined inside.*/runAsync(longRunningFunction).then(console.log); // 209685000000runAsync(() => 10 ** 3).then(console.log); // 1000let outsideVariable = 50;runAsync(() => typeof outsideVariable).then(console.log); // 'undefined'"},{"title":"runPromisesInSeries","type":0,"sectionRef":"#","url":"docs/runPromisesInSeries","content":"Runs an array of promises in series.Use Array.prototype.reduce() to create a promise chain, where each promise returns the next promise when resolved.Copyconst runPromisesInSeries = ps => ps.reduce((p, next) => p.then(next), Promise.resolve());Copyconst delay = d => new Promise(r => setTimeout(r, d));runPromisesInSeries([() => delay(1000), () => delay(2000)]); // Executes each promise sequentially, taking a total of 3 seconds to complete"},{"title":"sample","type":0,"sectionRef":"#","url":"docs/sample","content":"Returns a random element from an array.Use Math.random() to generate a random number, multiply it by length and round it off to the nearest whole number using Math.floor(). This method also works with strings.Copyconst sample = arr => arr[Math.floor(Math.random() * arr.length)];Copysample([3, 7, 9, 11]); // 9"},{"title":"sampleSize","type":0,"sectionRef":"#","url":"docs/sampleSize","content":"Gets n random elements at unique keys from array up to the size of array.Shuffle the array using the Fisher-Yates algorithm. Use Array.prototype.slice() to get the first n elements. Omit the second argument, n to get only one element at random from the array.Copyconst sampleSize = ([...arr], n = 1) => { let m = arr.length; while (m) { const i = Math.floor(Math.random() * m--); [arr[m], arr[i]] = [arr[i], arr[m]]; } return arr.slice(0, n);};CopysampleSize([1, 2, 3], 2); // [3,1]sampleSize([1, 2, 3], 4); // [2,3,1]"},{"title":"scrollToTop","type":0,"sectionRef":"#","url":"docs/scrollToTop","content":"Smooth-scrolls to the top of the page.Get distance from top using document.documentElement.scrollTop or document.body.scrollTop. Scroll by a fraction of the distance from the top. Use window.requestAnimationFrame() to animate the scrolling.Copyconst scrollToTop = () => { const c = document.documentElement.scrollTop || document.body.scrollTop; if (c > 0) { window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c / 8); }};CopyscrollToTop();"},{"title":"sdbm","type":0,"sectionRef":"#","url":"docs/sdbm","content":"Hashes the input string into a whole number.Use String.prototype.split('') and Array.prototype.reduce() to create a hash of the input string, utilizing bit shifting.Copyconst sdbm = str => { let arr = str.split(''); return arr.reduce( (hashCode, currentVal) => (hashCode = currentVal.charCodeAt(0) + (hashCode << 6) + (hashCode << 16) - hashCode), 0 );};Copysdbm('name'); // -3521204949"},{"title":"serializeCookie","type":0,"sectionRef":"#","url":"docs/serializeCookie","content":"Serialize a cookie name-value pair into a Set-Cookie header string.Use template literals and encodeURIComponent() to create the appropriate string.Copyconst serializeCookie = (name, val) => `${encodeURIComponent(name)}=${encodeURIComponent(val)}`;CopyserializeCookie('foo', 'bar'); // 'foo=bar'"},{"title":"serializeForm","type":0,"sectionRef":"#","url":"docs/serializeForm","content":"Encode a set of form elements as a query string.Use the FormData constructor to convert the HTML form to FormData, Array.from() to convert to an array, passing a map function as the second argument. Use Array.prototype.map() and window.encodeURIComponent() to encode each field's value. Use Array.prototype.join() with appropriate argumens to produce an appropriate query string.Copyconst serializeForm = form => Array.from(new FormData(form), field => field.map(encodeURIComponent).join('=')).join('&');CopyserializeForm(document.querySelector('#form')); // email=test%40email.com&name=Test%20Name"},{"title":"setStyle","type":0,"sectionRef":"#","url":"docs/setStyle","content":"Sets the value of a CSS rule for the specified HTML element.Use element.style to set the value of the CSS rule for the specified element to val.Copyconst setStyle = (el, ruleName, val) => (el.style[ruleName] = val);CopysetStyle(document.querySelector('p'), 'font-size', '20px');// The first <p> element on the page will have a font-size of 20px"},{"title":"shallowClone","type":0,"sectionRef":"#","url":"docs/shallowClone","content":"Creates a shallow clone of an object.Use Object.assign() and an empty object ({}) to create a shallow clone of the original.Copyconst shallowClone = obj => Object.assign({}, obj);Copyconst a = { x: true, y: 1 };const b = shallowClone(a); // a !== b"},{"title":"shank","type":0,"sectionRef":"#","url":"docs/shank","content":"Has the same functionality as Array.prototype.splice(), but returning a new array instead of mutating the original array.Use Array.prototype.slice() and Array.prototype.concat() to get a new array with the new contents after removing existing elements and/or adding new elements. Omit the second argument, index, to start at 0. Omit the third argument, delCount, to remove 0 elements. Omit the fourth argument, elements, in order to not add any new elements.Copyconst shank = (arr, index = 0, delCount = 0, ...elements) => arr .slice(0, index) .concat(elements) .concat(arr.slice(index + delCount));Copyconst names = ['alpha', 'bravo', 'charlie'];const namesAndDelta = shank(names, 1, 0, 'delta'); // [ 'alpha', 'delta', 'bravo', 'charlie' ]const namesNoBravo = shank(names, 1, 1); // [ 'alpha', 'charlie' ]console.log(names); // ['alpha', 'bravo', 'charlie']"},{"title":"show","type":0,"sectionRef":"#","url":"docs/show","content":"Shows all the elements specified.Use the spread operator (...) and Array.prototype.forEach() to clear the display property for each element specified.Copyconst show = (...el) => [...el].forEach(e => (e.style.display = ''));Copyshow(...document.querySelectorAll('img')); // Shows all <img> elements on the page"},{"title":"shuffle","type":0,"sectionRef":"#","url":"docs/shuffle","content":"Randomizes the order of the values of an array, returning a new array.Use the Fisher-Yates algorithm to reorder the elements of the array.Copyconst shuffle = ([...arr]) => { let m = arr.length; while (m) { const i = Math.floor(Math.random() * m--); [arr[m], arr[i]] = [arr[i], arr[m]]; } return arr;};Copyconst foo = [1, 2, 3];shuffle(foo); // [2, 3, 1], foo = [1, 2, 3]"},{"title":"similarity","type":0,"sectionRef":"#","url":"docs/similarity","content":"Returns an array of elements that appear in both arrays.Use Array.prototype.filter() to remove values that are not part of values, determined using Array.prototype.includes().Copyconst similarity = (arr, values) => arr.filter(v => values.includes(v));Copysimilarity([1, 2, 3], [1, 2, 4]); // [1, 2]"},{"title":"size","type":0,"sectionRef":"#","url":"docs/size","content":"Gets the size of an array, object or string.Get type of val (array, object or string). Use length property for arrays. Use length or size value if available or number of keys for objects. Use size of a Blob object created from val for strings. Split strings into array of characters with split('') and return its length.Copy const size = val => Array.isArray(val) ? val.length : val && typeof val === 'object' ? val.size || val.length || Object.keys(val).length : typeof val === 'string' ? new Blob([val]).size : 0;Copysize([1, 2, 3, 4, 5]); // 5size('size'); // 4size({ one: 1, two: 2, three: 3 }); // 3"},{"title":"sleep","type":0,"sectionRef":"#","url":"docs/sleep","content":"Delays the execution of an asynchronous function.Delay executing part of an async function, by putting it to sleep, returning a Promise.Copyconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));Copyasync function sleepyWork() { console.log(\"I'm going to sleep for 1 second.\"); await sleep(1000); console.log('I woke up after 1 second.');}"},{"title":"smoothScroll","type":0,"sectionRef":"#","url":"docs/smoothScroll","content":"Smoothly scrolls the element on which it's called into the visible area of the browser window.Use .scrollIntoView method to scroll the element. Pass { behavior: 'smooth' } to .scrollIntoView so it scrolls smoothly.Copyconst smoothScroll = element => document.querySelector(element).scrollIntoView({ behavior: 'smooth' });CopysmoothScroll('#fooBar'); // scrolls smoothly to the element with the id fooBarsmoothScroll('.fooBar'); // scrolls smoothly to the first element with a class of fooBar"},{"title":"sortCharactersInString","type":0,"sectionRef":"#","url":"docs/sortCharactersInString","content":"Alphabetically sorts the characters in a string.Use the spread operator (...), Array.prototype.sort() and String.localeCompare() to sort the characters in str, recombine using String.prototype.join('').Copyconst sortCharactersInString = str => [...str].sort((a, b) => a.localeCompare(b)).join('');CopysortCharactersInString('cabbage'); // 'aabbceg'"},{"title":"sortedIndex","type":0,"sectionRef":"#","url":"docs/sortedIndex","content":"Returns the lowest index at which value should be inserted into array in order to maintain its sort order.Check if the array is sorted in descending order (loosely). Use Array.prototype.findIndex() to find the appropriate index where the element should be inserted.Copyconst sortedIndex = (arr, n) => { const isDescending = arr[0] > arr[arr.length - 1]; const index = arr.findIndex(el => (isDescending ? n >= el : n <= el)); return index === -1 ? arr.length : index;};CopysortedIndex([5, 3, 2, 1], 4); // 1sortedIndex([30, 50], 40); // 1"},{"title":"sortedIndexBy","type":0,"sectionRef":"#","url":"docs/sortedIndexBy","content":"Returns the lowest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.Check if the array is sorted in descending order (loosely). Use Array.prototype.findIndex() to find the appropriate index where the element should be inserted, based on the iterator function fn.Copyconst sortedIndexBy = (arr, n, fn) => { const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]); const val = fn(n); const index = arr.findIndex(el => (isDescending ? val >= fn(el) : val <= fn(el))); return index === -1 ? arr.length : index;};CopysortedIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 0"},{"title":"sortedLastIndex","type":0,"sectionRef":"#","url":"docs/sortedLastIndex","content":"Returns the highest index at which value should be inserted into array in order to maintain its sort order.Check if the array is sorted in descending order (loosely). Use Array.prototype.reverse() and Array.prototype.findIndex() to find the appropriate last index where the element should be inserted.Copyconst sortedLastIndex = (arr, n) => { const isDescending = arr[0] > arr[arr.length - 1]; const index = arr.reverse().findIndex(el => (isDescending ? n <= el : n >= el)); return index === -1 ? 0 : arr.length - index;};CopysortedLastIndex([10, 20, 30, 30, 40], 30); // 4"},{"title":"sortedLastIndexBy","type":0,"sectionRef":"#","url":"docs/sortedLastIndexBy","content":"Returns the highest index at which value should be inserted into array in order to maintain its sort order, based on a provided iterator function.Check if the array is sorted in descending order (loosely). Use Array.prototype.map() to apply the iterator function to all elements of the array. Use Array.prototype.reverse() and Array.prototype.findIndex() to find the appropriate last index where the element should be inserted, based on the provided iterator function.Copyconst sortedLastIndexBy = (arr, n, fn) => { const isDescending = fn(arr[0]) > fn(arr[arr.length - 1]); const val = fn(n); const index = arr .map(fn) .reverse() .findIndex(el => (isDescending ? val <= el : val >= el)); return index === -1 ? 0 : arr.length - index;};CopysortedLastIndexBy([{ x: 4 }, { x: 5 }], { x: 4 }, o => o.x); // 1"},{"title":"splitLines","type":0,"sectionRef":"#","url":"docs/splitLines","content":"Splits a multiline string into an array of lines.Use String.prototype.split() and a regular expression to match line breaks and create an array.Copyconst splitLines = str => str.split(/\\r?\\n/);CopysplitLines('This\\nis a\\nmultiline\\nstring.\\n'); // ['This', 'is a', 'multiline', 'string.' , '']"},{"title":"spreadOver","type":0,"sectionRef":"#","url":"docs/spreadOver","content":"Takes a variadic function and returns a closure that accepts an array of arguments to map to the inputs of the function.Use closures and the spread operator (...) to map the array of arguments to the inputs of the function.Copyconst spreadOver = fn => argsArr => fn(...argsArr);Copyconst arrayMax = spreadOver(Math.max);arrayMax([1, 2, 3]); // 3"},{"title":"stableSort","type":0,"sectionRef":"#","url":"docs/stableSort","content":"Performs stable sorting of an array, preserving the initial indexes of items when their values are the same. Does not mutate the original array, but returns a new array instead.Use Array.prototype.map() to pair each element of the input array with its corresponding index. Use Array.prototype.sort() and a compare function to sort the list, preserving their initial order if the items compared are equal. Use Array.prototype.map() to convert back to the initial array items.Copyconst stableSort = (arr, compare) => arr .map((item, index) => ({ item, index })) .sort((a, b) => compare(a.item, b.item) || a.index - b.index) .map(({ item }) => item);Copyconst arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];const stable = stableSort(arr, () => 0); // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"},{"title":"standardDeviation","type":0,"sectionRef":"#","url":"docs/standardDeviation","content":"Returns the standard deviation of an array of numbers.Use Array.prototype.reduce() to calculate the mean, variance and the sum of the variance of the values, the variance of the values, then determine the standard deviation. You can omit the second argument to get the sample standard deviation or set it to true to get the population standard deviation.Copyconst standardDeviation = (arr, usePopulation = false) => { const mean = arr.reduce((acc, val) => acc + val, 0) / arr.length; return Math.sqrt( arr.reduce((acc, val) => acc.concat((val - mean) ** 2), []).reduce((acc, val) => acc + val, 0) / (arr.length - (usePopulation ? 0 : 1)) );};CopystandardDeviation([10, 2, 38, 23, 38, 23, 21]); // 13.284434142114991 (sample)standardDeviation([10, 2, 38, 23, 38, 23, 21], true); // 12.29899614287479 (population)"},{"title":"stringPermutations","type":0,"sectionRef":"#","url":"docs/stringPermutations","content":"Generates all permutations of a string (contains duplicates).⚠️ WARNING: This function's execution time increases exponentially with each character. Anything more than 8 to 10 characters will cause your browser to hang as it tries to solve all the different combinations.Use recursion. For each letter in the given string, create all the partial permutations for the rest of its letters. Use Array.prototype.map() to combine the letter with each partial permutation, then Array.prototype.reduce() to combine all permutations in one array. Base cases are for string length equal to 2 or 1.Copyconst stringPermutations = str => { if (str.length <= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str .split('') .reduce( (acc, letter, i) => acc.concat(stringPermutations(str.slice(0, i) + str.slice(i + 1)).map(val => letter + val)), [] );};CopystringPermutations('abc'); // ['abc','acb','bac','bca','cab','cba']"},{"title":"stripHTMLTags","type":0,"sectionRef":"#","url":"docs/stripHTMLTags","content":"Removes HTML/XML tags from string.Use a regular expression to remove HTML/XML tags from a string.Copyconst stripHTMLTags = str => str.replace(/<[^>]*>/g, '');CopystripHTMLTags('<p><em>lorem</em> <strong>ipsum</strong></p>'); // 'lorem ipsum'"},{"title":"sum","type":0,"sectionRef":"#","url":"docs/sum","content":"Returns the sum of two or more numbers/arrays.Use Array.prototype.reduce() to add each value to an accumulator, initialized with a value of 0.Copyconst sum = (...arr) => [...arr].reduce((acc, val) => acc + val, 0);Copysum(1, 2, 3, 4); // 10sum(...[1, 2, 3, 4]); // 10"},{"title":"sumBy","type":0,"sectionRef":"#","url":"docs/sumBy","content":"Returns the sum of an array, after mapping each element to a value using the provided function.Use Array.prototype.map() to map each element to the value returned by fn, Array.prototype.reduce() to add each value to an accumulator, initialized with a value of 0.Copyconst sumBy = (arr, fn) => arr.map(typeof fn === 'function' ? fn : val => val[fn]).reduce((acc, val) => acc + val, 0);CopysumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], o => o.n); // 20sumBy([{ n: 4 }, { n: 2 }, { n: 8 }, { n: 6 }], 'n'); // 20"},{"title":"sumPower","type":0,"sectionRef":"#","url":"docs/sumPower","content":"Returns the sum of the powers of all the numbers from start to end (both inclusive).Use Array.prototype.fill() to create an array of all the numbers in the target range, Array.prototype.map() and the exponent operator (**) to raise them to power and Array.prototype.reduce() to add them together. Omit the second argument, power, to use a default power of 2. Omit the third argument, start, to use a default starting value of 1.Copyconst sumPower = (end, power = 2, start = 1) => Array(end + 1 - start) .fill(0) .map((x, i) => (i + start) ** power) .reduce((a, b) => a + b, 0);CopysumPower(10); // 385sumPower(10, 3); // 3025sumPower(10, 3, 5); // 2925"},{"title":"supportsTouchEvents","type":0,"sectionRef":"#","url":"docs/supportsTouchEvents","content":"Returns true if touch events are supported, false otherwise.Check if ontouchstart exists in window or window.DocumentTouch is true and the current document is an instance of it.Copyconst supportsTouchEvents = () => window && ('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch);CopysupportsTouchEvents(); // true"},{"title":"symmetricDifference","type":0,"sectionRef":"#","url":"docs/symmetricDifference","content":"Returns the symmetric difference between two arrays, without filtering out duplicate values.Create a Set from each array, then use Array.prototype.filter() on each of them to only keep values not contained in the other.Copyconst symmetricDifference = (a, b) => { const sA = new Set(a), sB = new Set(b); return [...a.filter(x => !sB.has(x)), ...b.filter(x => !sA.has(x))];};CopysymmetricDifference([1, 2, 3], [1, 2, 4]); // [3, 4]symmetricDifference([1, 2, 2], [1, 3, 1]); // [2, 2, 3]"},{"title":"symmetricDifferenceBy","type":0,"sectionRef":"#","url":"docs/symmetricDifferenceBy","content":"Returns the symmetric difference between two arrays, after applying the provided function to each array element of both.Create a Set by applying fn to each array's elements, then use Array.prototype.filter() on each of them to only keep values not contained in the other.Copyconst symmetricDifferenceBy = (a, b, fn) => { const sA = new Set(a.map(v => fn(v))), sB = new Set(b.map(v => fn(v))); return [...a.filter(x => !sB.has(fn(x))), ...b.filter(x => !sA.has(fn(x)))];};CopysymmetricDifferenceBy([2.1, 1.2], [2.3, 3.4], Math.floor); // [ 1.2, 3.4 ]"},{"title":"symmetricDifferenceWith","type":0,"sectionRef":"#","url":"docs/symmetricDifferenceWith","content":"Returns the symmetric difference between two arrays, using a provided function as a comparator.Use Array.prototype.filter() and Array.prototype.findIndex() to find the appropriate values.Copyconst symmetricDifferenceWith = (arr, val, comp) => [ ...arr.filter(a => val.findIndex(b => comp(a, b)) === -1), ...val.filter(a => arr.findIndex(b => comp(a, b)) === -1)];CopysymmetricDifferenceWith( [1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2, 3.9]"},{"title":"tail","type":0,"sectionRef":"#","url":"docs/tail","content":"Returns all elements in an array except for the first one.Return Array.prototype.slice(1) if the array's length is more than 1, otherwise, return the whole array.Copyconst tail = arr => (arr.length > 1 ? arr.slice(1) : arr);Copytail([1, 2, 3]); // [2,3]tail([1]); // [1]"},{"title":"take","type":0,"sectionRef":"#","url":"docs/take","content":"Returns an array with n elements removed from the beginning.Use Array.prototype.slice() to create a slice of the array with n elements taken from the beginning.Copyconst take = (arr, n = 1) => arr.slice(0, n);Copytake([1, 2, 3], 5); // [1, 2, 3]take([1, 2, 3], 0); // []"},{"title":"takeRight","type":0,"sectionRef":"#","url":"docs/takeRight","content":"Returns an array with n elements removed from the end.Use Array.prototype.slice() to create a slice of the array with n elements taken from the end.Copyconst takeRight = (arr, n = 1) => arr.slice(arr.length - n, arr.length);CopytakeRight([1, 2, 3], 2); // [ 2, 3 ]takeRight([1, 2, 3]); // [3]"},{"title":"takeRightWhile","type":0,"sectionRef":"#","url":"docs/takeRightWhile","content":"Removes elements from the end of an array until the passed function returns true. Returns the removed elements.Loop through the array, using a Array.prototype.reduceRight() and accumulating elements while the function returns falsy value.Copyconst takeRightWhile = (arr, func) => arr.reduceRight((acc, el) => (func(el) ? acc : [el, ...acc]), []);CopytakeRightWhile([1, 2, 3, 4], n => n < 3); // [3, 4]"},{"title":"takeWhile","type":0,"sectionRef":"#","url":"docs/takeWhile","content":"Removes elements in an array until the passed function returns true. Returns the removed elements.Loop through the array, using a for...of loop over Array.prototype.entries() until the returned value from the function is true. Return the removed elements, using Array.prototype.slice().Copyconst takeWhile = (arr, func) => { for (const [i, val] of arr.entries()) if (func(val)) return arr.slice(0, i); return arr;};CopytakeWhile([1, 2, 3, 4], n => n >= 3); // [1, 2]"},{"title":"throttle","type":0,"sectionRef":"#","url":"docs/throttle","content":"Creates a throttled function that only invokes the provided function at most once per every wait millisecondsUse setTimeout() and clearTimeout() to throttle the given method, fn. Use Function.prototype.apply() to apply the this context to the function and provide the necessary arguments. Use Date.now() to keep track of the last time the throttled function was invoked. Omit the second argument, wait, to set the timeout at a default of 0 ms.Copyconst throttle = (fn, wait) => { let inThrottle, lastFn, lastTime; return function() { const context = this, args = arguments; if (!inThrottle) { fn.apply(context, args); lastTime = Date.now(); inThrottle = true; } else { clearTimeout(lastFn); lastFn = setTimeout(function() { if (Date.now() - lastTime >= wait) { fn.apply(context, args); lastTime = Date.now(); } }, Math.max(wait - (Date.now() - lastTime), 0)); } };};Copywindow.addEventListener( 'resize', throttle(function(evt) { console.log(window.innerWidth); console.log(window.innerHeight); }, 250)); // Will log the window dimensions at most every 250ms"},{"title":"timeTaken","type":0,"sectionRef":"#","url":"docs/timeTaken","content":"Measures the time taken by a function to execute.Use console.time() and console.timeEnd() to measure the difference between the start and end times to determine how long the callback took to execute.Copyconst timeTaken = callback => { console.time('timeTaken'); const r = callback(); console.timeEnd('timeTaken'); return r;};CopytimeTaken(() => Math.pow(2, 10)); // 1024, (logged): timeTaken: 0.02099609375ms"},{"title":"times","type":0,"sectionRef":"#","url":"docs/times","content":"Iterates over a callback n timesUse Function.call() to call fn n times or until it returns false. Omit the last argument, context, to use an undefined object (or the global object in non-strict mode).Copyconst times = (n, fn, context = undefined) => { let i = 0; while (fn.call(context, i) !== false && ++i < n) {}};Copyvar output = '';times(5, i => (output += i));console.log(output); // 01234"},{"title":"toCamelCase","type":0,"sectionRef":"#","url":"docs/toCamelCase","content":"Converts a string to camelcase.Break the string into words and combine them capitalizing the first letter of each word, using a regexp.Copyconst toCamelCase = str => { let s = str && str .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g) .map(x => x.slice(0, 1).toUpperCase() + x.slice(1).toLowerCase()) .join(''); return s.slice(0, 1).toLowerCase() + s.slice(1);};CopytoCamelCase('some_database_field_name'); // 'someDatabaseFieldName'toCamelCase('Some label that needs to be camelized'); // 'someLabelThatNeedsToBeCamelized'toCamelCase('some-javascript-property'); // 'someJavascriptProperty'toCamelCase('some-mixed_string with spaces_underscores-and-hyphens'); // 'someMixedStringWithSpacesUnderscoresAndHyphens'"},{"title":"toCurrency","type":0,"sectionRef":"#","url":"docs/toCurrency","content":"Take a number and return specified currency formatting.Use Intl.NumberFormat to enable country / currency sensitive formatting.Copyconst toCurrency = (n, curr, LanguageFormat = undefined) => Intl.NumberFormat(LanguageFormat, { style: 'currency', currency: curr }).format(n);CopytoCurrency(123456.789, 'EUR'); // €123,456.79 | currency: Euro | currencyLangFormat: LocaltoCurrency(123456.789, 'USD', 'en-us'); // $123,456.79 | currency: US Dollar | currencyLangFormat: English (United States)toCurrency(123456.789, 'USD', 'fa'); // ۱۲۳٬۴۵۶٫۷۹ ؜$ | currency: US Dollar | currencyLangFormat: FarsitoCurrency(322342436423.2435, 'JPY'); // ¥322,342,436,423 | currency: Japanese Yen | currencyLangFormat: LocaltoCurrency(322342436423.2435, 'JPY', 'fi'); // 322 342 436 423 ¥ | currency: Japanese Yen | currencyLangFormat: Finnish"},{"title":"toDecimalMark","type":0,"sectionRef":"#","url":"docs/toDecimalMark","content":"Converts a number to a decimal mark formatted string.Use Number.prototype.toLocaleString() to convert the numbre to decimal mark format.Copyconst toDecimalMark = num => num.toLocaleString('en-US');CopytoDecimalMark(12305030388.9087); // \"12,305,030,388.909\""},{"title":"toHash","type":0,"sectionRef":"#","url":"docs/toHash","content":"Reduces a given Array-like into a value hash (keyed data store).Given an Iterable or Array-like structure, call Array.prototype.reduce.call() on the provided object to step over it and return an Object, keyed by the reference value.Copyconst toHash = (object, key) => Array.prototype.reduce.call( object, (acc, data, index) => ((acc[!key ? index : data[key]] = data), acc), {} );CopytoHash([4, 3, 2, 1]); // { 0: 4, 1: 3, 2: 2, 3: 1 }toHash([{ a: 'label' }], 'a'); // { label: { a: 'label' } }// A more in depth example:let users = [{ id: 1, first: 'Jon' }, { id: 2, first: 'Joe' }, { id: 3, first: 'Moe' }];let managers = [{ manager: 1, employees: [2, 3] }];// We use function here because we want a bindable reference, but a closure referencing the hash would work, too.managers.forEach( manager => (manager.employees = manager.employees.map(function(id) { return this[id]; }, toHash(users, 'id'))));managers; // [ { manager:1, employees: [ { id: 2, first: \"Joe\" }, { id: 3, first: \"Moe\" } ] } ]"},{"title":"toKebabCase","type":0,"sectionRef":"#","url":"docs/toKebabCase","content":"Converts a string to kebab case.Break the string into words and combine them adding - as a separator, using a regexp.Copyconst toKebabCase = str => str && str .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g) .map(x => x.toLowerCase()) .join('-');CopytoKebabCase('camelCase'); // 'camel-case'toKebabCase('some text'); // 'some-text'toKebabCase('some-mixed_string With spaces_underscores-and-hyphens'); // 'some-mixed-string-with-spaces-underscores-and-hyphens'toKebabCase('AllThe-small Things'); // \"all-the-small-things\"toKebabCase('IAmListeningToFMWhileLoadingDifferentURLOnMyBrowserAndAlsoEditingSomeXMLAndHTML'); // \"i-am-listening-to-fm-while-loading-different-url-on-my-browser-and-also-editing-xml-and-html\""},{"title":"toOrdinalSuffix","type":0,"sectionRef":"#","url":"docs/toOrdinalSuffix","content":"Adds an ordinal suffix to a number.Use the modulo operator (%) to find values of single and tens digits. Find which ordinal pattern digits match. If digit is found in teens pattern, use teens ordinal.Copyconst toOrdinalSuffix = num => { const int = parseInt(num), digits = [int % 10, int % 100], ordinals = ['st', 'nd', 'rd', 'th'], oPattern = [1, 2, 3, 4], tPattern = [11, 12, 13, 14, 15, 16, 17, 18, 19]; return oPattern.includes(digits[0]) && !tPattern.includes(digits[1]) ? int + ordinals[digits[0] - 1] : int + ordinals[3];};CopytoOrdinalSuffix('123'); // \"123rd\""},{"title":"toPairs","type":0,"sectionRef":"#","url":"docs/toPairs","content":"Creates an array of key-value pair arrays from an object or other iterable (object, array, string, set etc.).Check if Symbol.iterator is defined and, if so, use Array.prototype.entries() to get an iterator for the given iterable, Array.from() to convert the result to an array of key-value pair arrays. If Symbol.iterator is not defined for obj, use Object.entries() instead.Copyconst toPairs = obj => obj[Symbol.iterator] instanceof Function && obj.entries instanceof Function ? Array.from(obj.entries()) : Object.entries(obj);CopytoPairs({ a: 1, b: 2 }); // [ ['a', 1], ['b', 2] ]toPairs([2, 4, 8]); // [ [0, 2], [1, 4], [2, 8] ]toPairs('shy'); // [ ['0', 's'], ['1', 'h'], ['2', 'y'] ]toPairs(new Set(['a', 'b', 'c', 'a'])); // [ ['a', 'a'], ['b', 'b'], ['c', 'c'] ]"},{"title":"toSafeInteger","type":0,"sectionRef":"#","url":"docs/toSafeInteger","content":"Converts a value to a safe integer.Use Math.max() and Math.min() to find the closest safe value. Use Math.round() to convert to an integer.Copyconst toSafeInteger = num => Math.round(Math.max(Math.min(num, Number.MAX_SAFE_INTEGER), Number.MIN_SAFE_INTEGER));CopytoSafeInteger('3.2'); // 3toSafeInteger(Infinity); // 9007199254740991"},{"title":"toSnakeCase","type":0,"sectionRef":"#","url":"docs/toSnakeCase","content":"Converts a string to snake case.Break the string into words and combine them adding _ as a separator, using a regexp.Copyconst toSnakeCase = str => str && str .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g) .map(x => x.toLowerCase()) .join('_');CopytoSnakeCase('camelCase'); // 'camel_case'toSnakeCase('some text'); // 'some_text'toSnakeCase('some-mixed_string With spaces_underscores-and-hyphens'); // 'some_mixed_string_with_spaces_underscores_and_hyphens'toSnakeCase('AllThe-small Things'); // \"all_the_small_things\"toSnakeCase('IAmListeningToFMWhileLoadingDifferentURLOnMyBrowserAndAlsoEditingSomeXMLAndHTML'); // \"i_am_listening_to_fm_while_loading_different_url_on_my_browser_and_also_editing_some_xml_and_html\""},{"title":"toTitleCase","type":0,"sectionRef":"#","url":"docs/toTitleCase","content":"Converts a string to title case.Break the string into words, using a regexp, and combine them capitalizing the first letter of each word and adding a whitespace between them.Copyconst toTitleCase = str => str .match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g) .map(x => x.charAt(0).toUpperCase() + x.slice(1)) .join(' ');CopytoTitleCase('some_database_field_name'); // 'Some Database Field Name'toTitleCase('Some label that needs to be title-cased'); // 'Some Label That Needs To Be Title Cased'toTitleCase('some-package-name'); // 'Some Package Name'toTitleCase('some-mixed_string with spaces_underscores-and-hyphens'); // 'Some Mixed String With Spaces Underscores And Hyphens'"},{"title":"toggleClass","type":0,"sectionRef":"#","url":"docs/toggleClass","content":"Toggles a class for an HTML element.Use element.classList.toggle() to toggle the specified class for the element.Copyconst toggleClass = (el, className) => el.classList.toggle(className);CopytoggleClass(document.querySelector('p.special'), 'special');// The paragraph will not have the 'special' class anymore"},{"title":"tomorrow","type":0,"sectionRef":"#","url":"docs/tomorrow","content":"Results in a string representation of tomorrow's date.Use new Date() to get the current date, increment by one using Date.getDate() and set the value to the result using Date.setDate(). Use Date.prototype.toISOString() to return a string in yyyy-mm-dd format.Copyconst tomorrow = () => { let t = new Date(); t.setDate(t.getDate() + 1); return t.toISOString().split('T')[0];};Copytomorrow(); // 2018-10-19 (if current date is 2018-10-18)"},{"title":"transform","type":0,"sectionRef":"#","url":"docs/transform","content":"Applies a function against an accumulator and each key in the object (from left to right).Use Object.keys(obj) to iterate over each key in the object, Array.prototype.reduce() to call the apply the specified function against the given accumulator.Copyconst transform = (obj, fn, acc) => Object.keys(obj).reduce((a, k) => fn(a, obj[k], k, obj), acc);Copytransform( { a: 1, b: 2, c: 1 }, (r, v, k) => { (r[v] || (r[v] = [])).push(k); return r; }, {}); // { '1': ['a', 'c'], '2': ['b'] }"},{"title":"triggerEvent","type":0,"sectionRef":"#","url":"docs/triggerEvent","content":"Triggers a specific event on a given element, optionally passing custom data.Use new CustomEvent() to create an event from the specified eventType and details. Use el.dispatchEvent() to trigger the newly created event on the given element. Omit the third argument, detail, if you do not want to pass custom data to the triggered event.Copyconst triggerEvent = (el, eventType, detail) => el.dispatchEvent(new CustomEvent(eventType, { detail }));CopytriggerEvent(document.getElementById('myId'), 'click');triggerEvent(document.getElementById('myId'), 'click', { username: 'bob' });"},{"title":"truncateString","type":0,"sectionRef":"#","url":"docs/truncateString","content":"Truncates a string up to a specified length.Determine if the string's length is greater than num. Return the string truncated to the desired length, with '...' appended to the end or the original string.Copyconst truncateString = (str, num) => str.length > num ? str.slice(0, num > 3 ? num - 3 : num) + '...' : str;CopytruncateString('boomerang', 7); // 'boom...'"},{"title":"truthCheckCollection","type":0,"sectionRef":"#","url":"docs/truthCheckCollection","content":"Checks if the predicate (second argument) is truthy on all elements of a collection (first argument).Use Array.prototype.every() to check if each passed object has the specified property and if it returns a truthy value.Copyconst truthCheckCollection = (collection, pre) => collection.every(obj => obj[pre]);CopytruthCheckCollection([{ user: 'Tinky-Winky', sex: 'male' }, { user: 'Dipsy', sex: 'male' }], 'sex'); // true"},{"title":"unary","type":0,"sectionRef":"#","url":"docs/unary","content":"Creates a function that accepts up to one argument, ignoring any additional arguments.Call the provided function, fn, with just the first argument given.Copyconst unary = fn => val => fn(val);Copy['6', '8', '10'].map(unary(parseInt)); // [6, 8, 10]"},{"title":"uncurry","type":0,"sectionRef":"#","url":"docs/uncurry","content":"Uncurries a function up to depth n.Return a variadic function. Use Array.prototype.reduce() on the provided arguments to call each subsequent curry level of the function. If the length of the provided arguments is less than n throw an error. Otherwise, call fn with the proper amount of arguments, using Array.prototype.slice(0, n). Omit the second argument, n, to uncurry up to depth 1.Copyconst uncurry = (fn, n = 1) => (...args) => { const next = acc => args => args.reduce((x, y) => x(y), acc); if (n > args.length) throw new RangeError('Arguments too few!'); return next(fn)(args.slice(0, n));};Copyconst add = x => y => z => x + y + z;const uncurriedAdd = uncurry(add, 3);uncurriedAdd(1, 2, 3); // 6"},{"title":"unescapeHTML","type":0,"sectionRef":"#","url":"docs/unescapeHTML","content":"Unescapes escaped HTML characters.Use String.prototype.replace() with a regex that matches the characters that need to be unescaped, using a callback function to replace each escaped character instance with its associated unescaped character using a dictionary (object).Copyconst unescapeHTML = str => str.replace( /&amp;|&lt;|&gt;|&#39;|&quot;/g, tag => ({ '&amp;': '&', '&lt;': '<', '&gt;': '>', '&#39;': \"'\", '&quot;': '\"' }[tag] || tag) );CopyunescapeHTML('&lt;a href=&quot;#&quot;&gt;Me &amp; you&lt;/a&gt;'); // '<a href=\"#\">Me & you</a>'"},{"title":"unflattenObject","type":0,"sectionRef":"#","url":"docs/unflattenObject","content":"Unflatten an object with the paths for keys.Use Object.keys(obj) combined with Array.prototype.reduce() to convert flattened path node to a leaf node. If the value of a key contains a dot delimiter (.), use Array.prototype.split('.'), string transformations and JSON.parse() to create an object, then Object.assign() to create the leaf node. Otherwise, add the appropriate key-value pair to the accumulator object.Copyconst unflattenObject = obj => Object.keys(obj).reduce((acc, k) => { if (k.indexOf('.') !== -1) { const keys = k.split('.'); Object.assign( acc, JSON.parse( '{' + keys.map((v, i) => (i !== keys.length - 1 ? `\"${v}\":{` : `\"${v}\":`)).join('') + obj[k] + '}'.repeat(keys.length) ) ); } else acc[k] = obj[k]; return acc; }, {});CopyunflattenObject({ 'a.b.c': 1, d: 1 }); // { a: { b: { c: 1 } }, d: 1 }"},{"title":"unfold","type":0,"sectionRef":"#","url":"docs/unfold","content":"Builds an array, using an iterator function and an initial seed value.Use a while loop and Array.prototype.push() to call the function repeatedly until it returns false. The iterator function accepts one argument (seed) and must always return an array with two elements ([value, nextSeed]) or false to terminate.Copyconst unfold = (fn, seed) => { let result = [], val = [null, seed]; while ((val = fn(val[1]))) result.push(val[0]); return result;};Copyvar f = n => (n > 50 ? false : [-n, n + 10]);unfold(f, 10); // [-10, -20, -30, -40, -50]"},{"title":"union","type":0,"sectionRef":"#","url":"docs/union","content":"Returns every element that exists in any of the two arrays once.Create a Set with all values of a and b and convert to an array.Copyconst union = (a, b) => Array.from(new Set([...a, ...b]));Copyunion([1, 2, 3], [4, 3, 2]); // [1, 2, 3, 4]"},{"title":"unionBy","type":0,"sectionRef":"#","url":"docs/unionBy","content":"Returns every element that exists in any of the two arrays once, after applying the provided function to each array element of both.Create a Set by applying all fn to all values of a. Create a Set from a and all elements in b whose value, after applying fn does not match a value in the previously created set. Return the last set converted to an array.Copyconst unionBy = (a, b, fn) => { const s = new Set(a.map(fn)); return Array.from(new Set([...a, ...b.filter(x => !s.has(fn(x)))]));};CopyunionBy([2.1], [1.2, 2.3], Math.floor); // [2.1, 1.2]"},{"title":"unionWith","type":0,"sectionRef":"#","url":"docs/unionWith","content":"Returns every element that exists in any of the two arrays once, using a provided comparator function.Create a Set with all values of a and values in b for which the comparator finds no matches in a, using Array.prototype.findIndex().Copyconst unionWith = (a, b, comp) => Array.from(new Set([...a, ...b.filter(x => a.findIndex(y => comp(x, y)) === -1)]));CopyunionWith([1, 1.2, 1.5, 3, 0], [1.9, 3, 0, 3.9], (a, b) => Math.round(a) === Math.round(b)); // [1, 1.2, 1.5, 3, 0, 3.9]"},{"title":"uniqueElements","type":0,"sectionRef":"#","url":"docs/uniqueElements","content":"Returns all unique values in an array.Create a Set from the given array to discard duplicated values, then use the spread operator (...) to convert it back to an array.Copyconst uniqueElements = arr => [...new Set(arr)];CopyuniqueElements([1, 2, 2, 3, 4, 4, 5]); // [1, 2, 3, 4, 5]"},{"title":"uniqueElementsBy","type":0,"sectionRef":"#","url":"docs/uniqueElementsBy","content":"Returns all unique values of an array, based on a provided comparator function.Use Array.prototype.reduce() and Array.prototype.some() for an array containing only the first unique occurrence of each value, based on the comparator function, fn. The comparator function takes two arguments: the values of the two elements being compared.Copyconst uniqueElementsBy = (arr, fn) => arr.reduce((acc, v) => { if (!acc.some(x => fn(v, x))) acc.push(v); return acc; }, []);CopyuniqueElementsBy( [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' }, { id: 1, value: 'd' }, { id: 0, value: 'e' } ], (a, b) => a.id == b.id); // [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' } ]"},{"title":"uniqueElementsByRight","type":0,"sectionRef":"#","url":"docs/uniqueElementsByRight","content":"Returns all unique values of an array, based on a provided comparator function, starting from the right.Use Array.prototype.reduceRight() and Array.prototype.some() for an array containing only the last unique occurrence of each value, based on the comparator function, fn. The comparator function takes two arguments: the values of the two elements being compared.Copyconst uniqueElementsByRight = (arr, fn) => arr.reduceRight((acc, v) => { if (!acc.some(x => fn(v, x))) acc.push(v); return acc; }, []);CopyuniqueElementsByRight( [ { id: 0, value: 'a' }, { id: 1, value: 'b' }, { id: 2, value: 'c' }, { id: 1, value: 'd' }, { id: 0, value: 'e' } ], (a, b) => a.id == b.id); // [ { id: 0, value: 'e' }, { id: 1, value: 'd' }, { id: 2, value: 'c' } ]"},{"title":"uniqueSymmetricDifference","type":0,"sectionRef":"#","url":"docs/uniqueSymmetricDifference","content":"Returns the unique symmetric difference between two arrays, not containing duplicate values from either array.Use Array.prototype.filter() and Array.prototype.includes() on each array to remove values contained in the other, then create a Set from the results, removing duplicate values.Copyconst uniqueSymmetricDifference = (a, b) => [ ...new Set([...a.filter(v => !b.includes(v)), ...b.filter(v => !a.includes(v))])];CopyuniqueSymmetricDifference([1, 2, 3], [1, 2, 4]); // [3, 4]uniqueSymmetricDifference([1, 2, 2], [1, 3, 1]); // [2, 3]"},{"title":"untildify","type":0,"sectionRef":"#","url":"docs/untildify","content":"Converts a tilde path to an absolute path.Use String.prototype.replace() with a regular expression and OS.homedir() to replace the ~ in the start of the path with the home directory.Copyconst untildify = str => str.replace(/^~($|\\/|\\\\)/, `${require('os').homedir()}$1`);Copyuntildify('~/node'); // '/Users/aUser/node'"},{"title":"unzip","type":0,"sectionRef":"#","url":"docs/unzip","content":"Creates an array of arrays, ungrouping the elements in an array produced by zip.Use Math.max.apply() to get the longest subarray in the array, Array.prototype.map() to make each element an array. Use Array.prototype.reduce() and Array.prototype.forEach() to map grouped values to individual arrays.Copyconst unzip = arr => arr.reduce( (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc), Array.from({ length: Math.max(...arr.map(x => x.length)) }).map(x => []) );Copyunzip([['a', 1, true], ['b', 2, false]]); // [['a', 'b'], [1, 2], [true, false]]unzip([['a', 1, true], ['b', 2]]); // [['a', 'b'], [1, 2], [true]]"},{"title":"unzipWith","type":0,"sectionRef":"#","url":"docs/unzipWith","content":"Creates an array of elements, ungrouping the elements in an array produced by zip and applying the provided function.Use Math.max.apply() to get the longest subarray in the array, Array.prototype.map() to make each element an array. Use Array.prototype.reduce() and Array.prototype.forEach() to map grouped values to individual arrays. Use Array.prototype.map() and the spread operator (...) to apply fn to each individual group of elements.Copyconst unzipWith = (arr, fn) => arr .reduce( (acc, val) => (val.forEach((v, i) => acc[i].push(v)), acc), Array.from({ length: Math.max(...arr.map(x => x.length)) }).map(x => []) ) .map(val => fn(...val));CopyunzipWith([[1, 10, 100], [2, 20, 200]], (...args) => args.reduce((acc, v) => acc + v, 0)); // [3, 30, 300]"},{"title":"validateNumber","type":0,"sectionRef":"#","url":"docs/validateNumber","content":"Returns true if the given value is a number, false otherwise.Use !isNaN() in combination with parseFloat() to check if the argument is a number. Use isFinite() to check if the number is finite. Use Number() to check if the coercion holds.Copyconst validateNumber = n => !isNaN(parseFloat(n)) && isFinite(n) && Number(n) == n;CopyvalidateNumber('10'); // true"},{"title":"vectorAngle","type":0,"sectionRef":"#","url":"docs/vectorAngle","content":"Returns the angle (theta) between two vectors.Use Array.prototype.reduce(), Math.pow() and Math.sqrt() to calculate the magnitude of each vector and the scalar product of the two vectors. Use Math.acos() to calculate the arccos and get the theta value.Copyconst vectorAngle = (x, y) => { let mX = Math.sqrt(x.reduce((acc, n) => acc + Math.pow(n, 2), 0)); let mY = Math.sqrt(y.reduce((acc, n) => acc + Math.pow(n, 2), 0)); return Math.acos(x.reduce((acc, n, i) => acc + n * y[i], 0) / (mX * mY));};CopyvectorAngle([3, 4], [4, 3]); // 0.283794109208328"},{"title":"vectorDistance","type":0,"sectionRef":"#","url":"docs/vectorDistance","content":"Returns the distance between two vectors.Use Array.prototype.reduce(), Math.pow() and Math.sqrt() to calculate the Euclidean distance between two vectors.Copyconst vectorDistance = (x, y) => Math.sqrt(x.reduce((acc, val, i) => acc + Math.pow(val - y[i], 2), 0));CopyvectorDistance([10, 0, 5], [20, 0, 10]); // 11.180339887498949"},{"title":"weightedSample","type":0,"sectionRef":"#","url":"docs/weightedSample","content":"Returns a random element from an array, using the provided weights as the probabilities for each element.Use Array.prototype.reduce() to create an array of partial sums for each value in weights. Use Math.random() to generate a random number and Array.prototype.findIndex() to find the correct index based on the array previously produced. Finally, return the element of arr with the produced index.Copyconst weightedSample = (arr, weights) => { let roll = Math.random(); return arr[ weights .reduce((acc, w, i) => (i === 0 ? [w] : [...acc, acc[acc.length - 1] + w]), []) .findIndex((v, i, s) => roll >= (i === 0 ? 0 : s[i - 1]) && roll < v) ];};CopyweightedSample([3, 7, 9, 11], [0.1, 0.2, 0.6, 0.1]); // 9"},{"title":"when","type":0,"sectionRef":"#","url":"docs/when","content":"Tests a value, x, against a predicate function. If true, return fn(x). Else, return x. Return a function expecting a single value, x, that returns the appropriate value based on pred.Copyconst when = (pred, whenTrue) => x => (pred(x) ? whenTrue(x) : x);Copyconst doubleEvenNumbers = when(x => x % 2 === 0, x => x * 2);doubleEvenNumbers(2); // 4doubleEvenNumbers(1); // 1"},{"title":"without","type":0,"sectionRef":"#","url":"docs/without","content":"Filters out the elements of an array, that have one of the specified values.Use Array.prototype.filter() to create an array excluding(using !Array.includes()) all given values.Copyconst without = (arr, ...args) => arr.filter(v => !args.includes(v));Copywithout([2, 1, 2, 3], 1, 2); // [3]"},{"title":"words","type":0,"sectionRef":"#","url":"docs/words","content":"Converts a given string into an array of words.Use String.prototype.split() with a supplied pattern (defaults to non-alpha as a regexp) to convert to an array of strings. Use Array.prototype.filter() to remove any empty strings. Omit the second argument to use the default regexp.Copyconst words = (str, pattern = /[^a-zA-Z-]+/) => str.split(pattern).filter(Boolean);Copywords('I love javaScript!!'); // [\"I\", \"love\", \"javaScript\"]words('python, javaScript & coffee'); // [\"python\", \"javaScript\", \"coffee\"]"},{"title":"xProd","type":0,"sectionRef":"#","url":"docs/xProd","content":"Creates a new array out of the two supplied by creating each possible pair from the arrays.Use Array.prototype.reduce(), Array.prototype.map() and Array.prototype.concat() to produce every possible pair from the elements of the two arrays and save them in an array.Copyconst xProd = (a, b) => a.reduce((acc, x) => acc.concat(b.map(y => [x, y])), []);CopyxProd([1, 2], ['a', 'b']); // [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]"},{"title":"yesNo","type":0,"sectionRef":"#","url":"docs/yesNo","content":"Returns true if the string is y/yes or false if the string is n/no.Use RegExp.test() to check if the string evaluates to y/yes or n/no. Omit the second argument, def to set the default answer as no.Copyconst yesNo = (val, def = false) => /^(y|yes)$/i.test(val) ? true : /^(n|no)$/i.test(val) ? false : def;CopyyesNo('Y'); // trueyesNo('yes'); // trueyesNo('No'); // falseyesNo('Foo', true); // true"},{"title":"yesterday","type":0,"sectionRef":"#","url":"docs/yesterday","content":"Results in a string representation of yesterday's date.Use new Date() to get the current date, decrement by one using Date.getDate() and set the value to the result using Date.setDate(). Use Date.prototype.toISOString() to return a string in yyyy-mm-dd format.Copyconst yesterday = () => { let t = new Date(); t.setDate(t.getDate() - 1); return t.toISOString().split('T')[0];};Copyyesterday(); // 2018-10-17 (if current date is 2018-10-18)"},{"title":"zip","type":0,"sectionRef":"#","url":"docs/zip","content":"Creates an array of elements, grouped based on the position in the original arrays.Use Math.max.apply() to get the longest array in the arguments. Creates an array with that length as return value and use Array.from() with a map-function to create an array of grouped elements. If lengths of the argument-arrays vary, undefined is used where no value could be found.Copyconst zip = (...arrays) => { const maxLength = Math.max(...arrays.map(x => x.length)); return Array.from({ length: maxLength }).map((_, i) => { return Array.from({ length: arrays.length }, (_, k) => arrays[k][i]); });};Copyzip(['a', 'b'], [1, 2], [true, false]); // [['a', 1, true], ['b', 2, false]]zip(['a'], [1, 2], [true, false]); // [['a', 1, true], [undefined, 2, false]]"},{"title":"zipObject","type":0,"sectionRef":"#","url":"docs/zipObject","content":"Given an array of valid property identifiers and an array of values, return an object associating the properties to the values.Since an object can have undefined values but not undefined property pointers, the array of properties is used to decide the structure of the resulting object using Array.prototype.reduce().Copyconst zipObject = (props, values) => props.reduce((obj, prop, index) => ((obj[prop] = values[index]), obj), {});CopyzipObject(['a', 'b', 'c'], [1, 2]); // {a: 1, b: 2, c: undefined}zipObject(['a', 'b'], [1, 2, 3]); // {a: 1, b: 2}"},{"title":"zipWith","type":0,"sectionRef":"#","url":"docs/zipWith","content":"Creates an array of elements, grouped based on the position in the original arrays and using function as the last value to specify how grouped values should be combined.Check if the last argument provided is a function. Use Math.max() to get the longest array in the arguments. Creates an array with that length as return value and use Array.from() with a map-function to create an array of grouped elements. If lengths of the argument-arrays vary, undefined is used where no value could be found. The function is invoked with the elements of each group (...group).Copyconst zipWith = (...array) => { const fn = typeof array[array.length - 1] === 'function' ? array.pop() : undefined; return Array.from({ length: Math.max(...array.map(a => a.length)) }, (_, i) => fn ? fn(...array.map(a => a[i])) : array.map(a => a[i]) );};CopyzipWith([1, 2], [10, 20], [100, 200], (a, b, c) => a + b + c); // [111,222]zipWith( [1, 2, 3], [10, 20], [100, 200], (a, b, c) => (a != null ? a : 'a') + (b != null ? b : 'b') + (c != null ? c : 'c')); // [111, 222, '3bc']"}]